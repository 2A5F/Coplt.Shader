// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float2x2

public partial struct float2x2 : IComparable<float2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float2x2, float2x2, bool>
    , IComparisonOperators<float2x2, float2x2, b32m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float2x2, float2x2, bool>.operator <(float2x2 left, float2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2, float2x2, bool>.operator >(float2x2 left, float2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2, float2x2, bool>.operator <=(float2x2 left, float2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x2, float2x2, bool>.operator >=(float2x2 left, float2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <(float2x2 left, float2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >(float2x2 left, float2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <=(float2x2 left, float2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >=(float2x2 left, float2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // float2x2

#region float2x3

public partial struct float2x3 : IComparable<float2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float2x3, float2x3, bool>
    , IComparisonOperators<float2x3, float2x3, b32m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float2x3, float2x3, bool>.operator <(float2x3 left, float2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3, float2x3, bool>.operator >(float2x3 left, float2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3, float2x3, bool>.operator <=(float2x3 left, float2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x3, float2x3, bool>.operator >=(float2x3 left, float2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <(float2x3 left, float2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >(float2x3 left, float2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <=(float2x3 left, float2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >=(float2x3 left, float2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // float2x3

#region float2x4

public partial struct float2x4 : IComparable<float2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float2x4, float2x4, bool>
    , IComparisonOperators<float2x4, float2x4, b32m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float2x4, float2x4, bool>.operator <(float2x4 left, float2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4, float2x4, bool>.operator >(float2x4 left, float2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4, float2x4, bool>.operator <=(float2x4 left, float2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float2x4, float2x4, bool>.operator >=(float2x4 left, float2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <(float2x4 left, float2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >(float2x4 left, float2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <=(float2x4 left, float2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >=(float2x4 left, float2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // float2x4

#region float3x2

public partial struct float3x2 : IComparable<float3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float3x2, float3x2, bool>
    , IComparisonOperators<float3x2, float3x2, b32m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float3x2, float3x2, bool>.operator <(float3x2 left, float3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2, float3x2, bool>.operator >(float3x2 left, float3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2, float3x2, bool>.operator <=(float3x2 left, float3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x2, float3x2, bool>.operator >=(float3x2 left, float3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <(float3x2 left, float3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >(float3x2 left, float3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <=(float3x2 left, float3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >=(float3x2 left, float3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // float3x2

#region float3x3

public partial struct float3x3 : IComparable<float3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float3x3, float3x3, bool>
    , IComparisonOperators<float3x3, float3x3, b32m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float3x3, float3x3, bool>.operator <(float3x3 left, float3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3, float3x3, bool>.operator >(float3x3 left, float3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3, float3x3, bool>.operator <=(float3x3 left, float3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x3, float3x3, bool>.operator >=(float3x3 left, float3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <(float3x3 left, float3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >(float3x3 left, float3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <=(float3x3 left, float3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >=(float3x3 left, float3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // float3x3

#region float3x4

public partial struct float3x4 : IComparable<float3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float3x4, float3x4, bool>
    , IComparisonOperators<float3x4, float3x4, b32m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float3x4, float3x4, bool>.operator <(float3x4 left, float3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4, float3x4, bool>.operator >(float3x4 left, float3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4, float3x4, bool>.operator <=(float3x4 left, float3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float3x4, float3x4, bool>.operator >=(float3x4 left, float3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <(float3x4 left, float3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >(float3x4 left, float3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <=(float3x4 left, float3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >=(float3x4 left, float3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // float3x4

#region float4x2

public partial struct float4x2 : IComparable<float4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float4x2, float4x2, bool>
    , IComparisonOperators<float4x2, float4x2, b32m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float4x2, float4x2, bool>.operator <(float4x2 left, float4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2, float4x2, bool>.operator >(float4x2 left, float4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2, float4x2, bool>.operator <=(float4x2 left, float4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x2, float4x2, bool>.operator >=(float4x2 left, float4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <(float4x2 left, float4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >(float4x2 left, float4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <=(float4x2 left, float4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >=(float4x2 left, float4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // float4x2

#region float4x3

public partial struct float4x3 : IComparable<float4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float4x3, float4x3, bool>
    , IComparisonOperators<float4x3, float4x3, b32m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float4x3, float4x3, bool>.operator <(float4x3 left, float4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3, float4x3, bool>.operator >(float4x3 left, float4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3, float4x3, bool>.operator <=(float4x3 left, float4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x3, float4x3, bool>.operator >=(float4x3 left, float4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <(float4x3 left, float4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >(float4x3 left, float4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <=(float4x3 left, float4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >=(float4x3 left, float4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // float4x3

#region float4x4

public partial struct float4x4 : IComparable<float4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<float4x4, float4x4, bool>
    , IComparisonOperators<float4x4, float4x4, b32m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is float4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(float4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<float4x4, float4x4, bool>.operator <(float4x4 left, float4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4, float4x4, bool>.operator >(float4x4 left, float4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4, float4x4, bool>.operator <=(float4x4 left, float4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<float4x4, float4x4, bool>.operator >=(float4x4 left, float4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(float4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <(float4x4 left, float4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >(float4x4 left, float4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <=(float4x4 left, float4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >=(float4x4 left, float4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(float4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(float4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(float4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(float4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(float4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(float4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(float4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(float4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // float4x4

#region double2x2

public partial struct double2x2 : IComparable<double2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double2x2, double2x2, bool>
    , IComparisonOperators<double2x2, double2x2, b64m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double2x2, double2x2, bool>.operator <(double2x2 left, double2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2, double2x2, bool>.operator >(double2x2 left, double2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2, double2x2, bool>.operator <=(double2x2 left, double2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x2, double2x2, bool>.operator >=(double2x2 left, double2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <(double2x2 left, double2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >(double2x2 left, double2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <=(double2x2 left, double2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >=(double2x2 left, double2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // double2x2

#region double2x3

public partial struct double2x3 : IComparable<double2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double2x3, double2x3, bool>
    , IComparisonOperators<double2x3, double2x3, b64m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double2x3, double2x3, bool>.operator <(double2x3 left, double2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3, double2x3, bool>.operator >(double2x3 left, double2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3, double2x3, bool>.operator <=(double2x3 left, double2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x3, double2x3, bool>.operator >=(double2x3 left, double2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <(double2x3 left, double2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >(double2x3 left, double2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <=(double2x3 left, double2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >=(double2x3 left, double2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // double2x3

#region double2x4

public partial struct double2x4 : IComparable<double2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double2x4, double2x4, bool>
    , IComparisonOperators<double2x4, double2x4, b64m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double2x4, double2x4, bool>.operator <(double2x4 left, double2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4, double2x4, bool>.operator >(double2x4 left, double2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4, double2x4, bool>.operator <=(double2x4 left, double2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double2x4, double2x4, bool>.operator >=(double2x4 left, double2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <(double2x4 left, double2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >(double2x4 left, double2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <=(double2x4 left, double2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >=(double2x4 left, double2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // double2x4

#region double3x2

public partial struct double3x2 : IComparable<double3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double3x2, double3x2, bool>
    , IComparisonOperators<double3x2, double3x2, b64m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double3x2, double3x2, bool>.operator <(double3x2 left, double3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2, double3x2, bool>.operator >(double3x2 left, double3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2, double3x2, bool>.operator <=(double3x2 left, double3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x2, double3x2, bool>.operator >=(double3x2 left, double3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <(double3x2 left, double3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >(double3x2 left, double3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <=(double3x2 left, double3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >=(double3x2 left, double3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // double3x2

#region double3x3

public partial struct double3x3 : IComparable<double3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double3x3, double3x3, bool>
    , IComparisonOperators<double3x3, double3x3, b64m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double3x3, double3x3, bool>.operator <(double3x3 left, double3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3, double3x3, bool>.operator >(double3x3 left, double3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3, double3x3, bool>.operator <=(double3x3 left, double3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x3, double3x3, bool>.operator >=(double3x3 left, double3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <(double3x3 left, double3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >(double3x3 left, double3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <=(double3x3 left, double3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >=(double3x3 left, double3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // double3x3

#region double3x4

public partial struct double3x4 : IComparable<double3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double3x4, double3x4, bool>
    , IComparisonOperators<double3x4, double3x4, b64m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double3x4, double3x4, bool>.operator <(double3x4 left, double3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4, double3x4, bool>.operator >(double3x4 left, double3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4, double3x4, bool>.operator <=(double3x4 left, double3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double3x4, double3x4, bool>.operator >=(double3x4 left, double3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <(double3x4 left, double3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >(double3x4 left, double3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <=(double3x4 left, double3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >=(double3x4 left, double3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // double3x4

#region double4x2

public partial struct double4x2 : IComparable<double4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double4x2, double4x2, bool>
    , IComparisonOperators<double4x2, double4x2, b64m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double4x2, double4x2, bool>.operator <(double4x2 left, double4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2, double4x2, bool>.operator >(double4x2 left, double4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2, double4x2, bool>.operator <=(double4x2 left, double4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x2, double4x2, bool>.operator >=(double4x2 left, double4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <(double4x2 left, double4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >(double4x2 left, double4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <=(double4x2 left, double4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >=(double4x2 left, double4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // double4x2

#region double4x3

public partial struct double4x3 : IComparable<double4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double4x3, double4x3, bool>
    , IComparisonOperators<double4x3, double4x3, b64m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double4x3, double4x3, bool>.operator <(double4x3 left, double4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3, double4x3, bool>.operator >(double4x3 left, double4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3, double4x3, bool>.operator <=(double4x3 left, double4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x3, double4x3, bool>.operator >=(double4x3 left, double4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <(double4x3 left, double4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >(double4x3 left, double4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <=(double4x3 left, double4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >=(double4x3 left, double4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // double4x3

#region double4x4

public partial struct double4x4 : IComparable<double4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<double4x4, double4x4, bool>
    , IComparisonOperators<double4x4, double4x4, b64m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is double4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(double4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<double4x4, double4x4, bool>.operator <(double4x4 left, double4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4, double4x4, bool>.operator >(double4x4 left, double4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4, double4x4, bool>.operator <=(double4x4 left, double4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<double4x4, double4x4, bool>.operator >=(double4x4 left, double4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(double4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <(double4x4 left, double4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >(double4x4 left, double4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <=(double4x4 left, double4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >=(double4x4 left, double4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(double4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(double4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(double4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(double4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(double4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(double4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(double4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(double4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // double4x4

#region short2x2

public partial struct short2x2 : IComparable<short2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short2x2, short2x2, bool>
    , IComparisonOperators<short2x2, short2x2, b16m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short2x2, short2x2, bool>.operator <(short2x2 left, short2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x2, short2x2, bool>.operator >(short2x2 left, short2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x2, short2x2, bool>.operator <=(short2x2 left, short2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x2, short2x2, bool>.operator >=(short2x2 left, short2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <(short2x2 left, short2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >(short2x2 left, short2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <=(short2x2 left, short2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >=(short2x2 left, short2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // short2x2

#region short2x3

public partial struct short2x3 : IComparable<short2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short2x3, short2x3, bool>
    , IComparisonOperators<short2x3, short2x3, b16m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short2x3, short2x3, bool>.operator <(short2x3 left, short2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x3, short2x3, bool>.operator >(short2x3 left, short2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x3, short2x3, bool>.operator <=(short2x3 left, short2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x3, short2x3, bool>.operator >=(short2x3 left, short2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <(short2x3 left, short2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >(short2x3 left, short2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <=(short2x3 left, short2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >=(short2x3 left, short2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // short2x3

#region short2x4

public partial struct short2x4 : IComparable<short2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short2x4, short2x4, bool>
    , IComparisonOperators<short2x4, short2x4, b16m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short2x4, short2x4, bool>.operator <(short2x4 left, short2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x4, short2x4, bool>.operator >(short2x4 left, short2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x4, short2x4, bool>.operator <=(short2x4 left, short2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short2x4, short2x4, bool>.operator >=(short2x4 left, short2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <(short2x4 left, short2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >(short2x4 left, short2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <=(short2x4 left, short2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >=(short2x4 left, short2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // short2x4

#region short3x2

public partial struct short3x2 : IComparable<short3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short3x2, short3x2, bool>
    , IComparisonOperators<short3x2, short3x2, b16m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short3x2, short3x2, bool>.operator <(short3x2 left, short3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x2, short3x2, bool>.operator >(short3x2 left, short3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x2, short3x2, bool>.operator <=(short3x2 left, short3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x2, short3x2, bool>.operator >=(short3x2 left, short3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <(short3x2 left, short3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >(short3x2 left, short3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <=(short3x2 left, short3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >=(short3x2 left, short3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // short3x2

#region short3x3

public partial struct short3x3 : IComparable<short3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short3x3, short3x3, bool>
    , IComparisonOperators<short3x3, short3x3, b16m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short3x3, short3x3, bool>.operator <(short3x3 left, short3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x3, short3x3, bool>.operator >(short3x3 left, short3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x3, short3x3, bool>.operator <=(short3x3 left, short3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x3, short3x3, bool>.operator >=(short3x3 left, short3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <(short3x3 left, short3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >(short3x3 left, short3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <=(short3x3 left, short3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >=(short3x3 left, short3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // short3x3

#region short3x4

public partial struct short3x4 : IComparable<short3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short3x4, short3x4, bool>
    , IComparisonOperators<short3x4, short3x4, b16m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short3x4, short3x4, bool>.operator <(short3x4 left, short3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x4, short3x4, bool>.operator >(short3x4 left, short3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x4, short3x4, bool>.operator <=(short3x4 left, short3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short3x4, short3x4, bool>.operator >=(short3x4 left, short3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <(short3x4 left, short3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >(short3x4 left, short3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <=(short3x4 left, short3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >=(short3x4 left, short3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // short3x4

#region short4x2

public partial struct short4x2 : IComparable<short4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short4x2, short4x2, bool>
    , IComparisonOperators<short4x2, short4x2, b16m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short4x2, short4x2, bool>.operator <(short4x2 left, short4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x2, short4x2, bool>.operator >(short4x2 left, short4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x2, short4x2, bool>.operator <=(short4x2 left, short4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x2, short4x2, bool>.operator >=(short4x2 left, short4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <(short4x2 left, short4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >(short4x2 left, short4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <=(short4x2 left, short4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >=(short4x2 left, short4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // short4x2

#region short4x3

public partial struct short4x3 : IComparable<short4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short4x3, short4x3, bool>
    , IComparisonOperators<short4x3, short4x3, b16m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short4x3, short4x3, bool>.operator <(short4x3 left, short4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x3, short4x3, bool>.operator >(short4x3 left, short4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x3, short4x3, bool>.operator <=(short4x3 left, short4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x3, short4x3, bool>.operator >=(short4x3 left, short4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <(short4x3 left, short4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >(short4x3 left, short4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <=(short4x3 left, short4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >=(short4x3 left, short4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // short4x3

#region short4x4

public partial struct short4x4 : IComparable<short4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<short4x4, short4x4, bool>
    , IComparisonOperators<short4x4, short4x4, b16m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is short4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(short4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<short4x4, short4x4, bool>.operator <(short4x4 left, short4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x4, short4x4, bool>.operator >(short4x4 left, short4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x4, short4x4, bool>.operator <=(short4x4 left, short4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<short4x4, short4x4, bool>.operator >=(short4x4 left, short4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(short4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <(short4x4 left, short4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >(short4x4 left, short4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <=(short4x4 left, short4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >=(short4x4 left, short4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(short4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(short4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(short4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(short4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(short4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(short4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(short4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(short4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // short4x4

#region ushort2x2

public partial struct ushort2x2 : IComparable<ushort2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort2x2, ushort2x2, bool>
    , IComparisonOperators<ushort2x2, ushort2x2, b16m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort2x2, ushort2x2, bool>.operator <(ushort2x2 left, ushort2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x2, ushort2x2, bool>.operator >(ushort2x2 left, ushort2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x2, ushort2x2, bool>.operator <=(ushort2x2 left, ushort2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x2, ushort2x2, bool>.operator >=(ushort2x2 left, ushort2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <(ushort2x2 left, ushort2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >(ushort2x2 left, ushort2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <=(ushort2x2 left, ushort2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >=(ushort2x2 left, ushort2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ushort2x2

#region ushort2x3

public partial struct ushort2x3 : IComparable<ushort2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort2x3, ushort2x3, bool>
    , IComparisonOperators<ushort2x3, ushort2x3, b16m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort2x3, ushort2x3, bool>.operator <(ushort2x3 left, ushort2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x3, ushort2x3, bool>.operator >(ushort2x3 left, ushort2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x3, ushort2x3, bool>.operator <=(ushort2x3 left, ushort2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x3, ushort2x3, bool>.operator >=(ushort2x3 left, ushort2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <(ushort2x3 left, ushort2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >(ushort2x3 left, ushort2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <=(ushort2x3 left, ushort2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >=(ushort2x3 left, ushort2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ushort2x3

#region ushort2x4

public partial struct ushort2x4 : IComparable<ushort2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort2x4, ushort2x4, bool>
    , IComparisonOperators<ushort2x4, ushort2x4, b16m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort2x4, ushort2x4, bool>.operator <(ushort2x4 left, ushort2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x4, ushort2x4, bool>.operator >(ushort2x4 left, ushort2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x4, ushort2x4, bool>.operator <=(ushort2x4 left, ushort2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort2x4, ushort2x4, bool>.operator >=(ushort2x4 left, ushort2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <(ushort2x4 left, ushort2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >(ushort2x4 left, ushort2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <=(ushort2x4 left, ushort2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >=(ushort2x4 left, ushort2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ushort2x4

#region ushort3x2

public partial struct ushort3x2 : IComparable<ushort3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort3x2, ushort3x2, bool>
    , IComparisonOperators<ushort3x2, ushort3x2, b16m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort3x2, ushort3x2, bool>.operator <(ushort3x2 left, ushort3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x2, ushort3x2, bool>.operator >(ushort3x2 left, ushort3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x2, ushort3x2, bool>.operator <=(ushort3x2 left, ushort3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x2, ushort3x2, bool>.operator >=(ushort3x2 left, ushort3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <(ushort3x2 left, ushort3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >(ushort3x2 left, ushort3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <=(ushort3x2 left, ushort3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >=(ushort3x2 left, ushort3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ushort3x2

#region ushort3x3

public partial struct ushort3x3 : IComparable<ushort3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort3x3, ushort3x3, bool>
    , IComparisonOperators<ushort3x3, ushort3x3, b16m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort3x3, ushort3x3, bool>.operator <(ushort3x3 left, ushort3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x3, ushort3x3, bool>.operator >(ushort3x3 left, ushort3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x3, ushort3x3, bool>.operator <=(ushort3x3 left, ushort3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x3, ushort3x3, bool>.operator >=(ushort3x3 left, ushort3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <(ushort3x3 left, ushort3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >(ushort3x3 left, ushort3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <=(ushort3x3 left, ushort3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >=(ushort3x3 left, ushort3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ushort3x3

#region ushort3x4

public partial struct ushort3x4 : IComparable<ushort3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort3x4, ushort3x4, bool>
    , IComparisonOperators<ushort3x4, ushort3x4, b16m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort3x4, ushort3x4, bool>.operator <(ushort3x4 left, ushort3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x4, ushort3x4, bool>.operator >(ushort3x4 left, ushort3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x4, ushort3x4, bool>.operator <=(ushort3x4 left, ushort3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort3x4, ushort3x4, bool>.operator >=(ushort3x4 left, ushort3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <(ushort3x4 left, ushort3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >(ushort3x4 left, ushort3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <=(ushort3x4 left, ushort3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >=(ushort3x4 left, ushort3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ushort3x4

#region ushort4x2

public partial struct ushort4x2 : IComparable<ushort4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort4x2, ushort4x2, bool>
    , IComparisonOperators<ushort4x2, ushort4x2, b16m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort4x2, ushort4x2, bool>.operator <(ushort4x2 left, ushort4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x2, ushort4x2, bool>.operator >(ushort4x2 left, ushort4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x2, ushort4x2, bool>.operator <=(ushort4x2 left, ushort4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x2, ushort4x2, bool>.operator >=(ushort4x2 left, ushort4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <(ushort4x2 left, ushort4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >(ushort4x2 left, ushort4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <=(ushort4x2 left, ushort4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >=(ushort4x2 left, ushort4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ushort4x2

#region ushort4x3

public partial struct ushort4x3 : IComparable<ushort4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort4x3, ushort4x3, bool>
    , IComparisonOperators<ushort4x3, ushort4x3, b16m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort4x3, ushort4x3, bool>.operator <(ushort4x3 left, ushort4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x3, ushort4x3, bool>.operator >(ushort4x3 left, ushort4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x3, ushort4x3, bool>.operator <=(ushort4x3 left, ushort4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x3, ushort4x3, bool>.operator >=(ushort4x3 left, ushort4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <(ushort4x3 left, ushort4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >(ushort4x3 left, ushort4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <=(ushort4x3 left, ushort4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >=(ushort4x3 left, ushort4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ushort4x3

#region ushort4x4

public partial struct ushort4x4 : IComparable<ushort4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ushort4x4, ushort4x4, bool>
    , IComparisonOperators<ushort4x4, ushort4x4, b16m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ushort4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ushort4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ushort4x4, ushort4x4, bool>.operator <(ushort4x4 left, ushort4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x4, ushort4x4, bool>.operator >(ushort4x4 left, ushort4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x4, ushort4x4, bool>.operator <=(ushort4x4 left, ushort4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ushort4x4, ushort4x4, bool>.operator >=(ushort4x4 left, ushort4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ushort4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <(ushort4x4 left, ushort4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >(ushort4x4 left, ushort4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <=(ushort4x4 left, ushort4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >=(ushort4x4 left, ushort4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ushort4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ushort4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ushort4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ushort4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ushort4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ushort4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ushort4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ushort4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ushort4x4

#region int2x2

public partial struct int2x2 : IComparable<int2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int2x2, int2x2, bool>
    , IComparisonOperators<int2x2, int2x2, b32m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int2x2, int2x2, bool>.operator <(int2x2 left, int2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2, int2x2, bool>.operator >(int2x2 left, int2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2, int2x2, bool>.operator <=(int2x2 left, int2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x2, int2x2, bool>.operator >=(int2x2 left, int2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <(int2x2 left, int2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >(int2x2 left, int2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <=(int2x2 left, int2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >=(int2x2 left, int2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // int2x2

#region int2x3

public partial struct int2x3 : IComparable<int2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int2x3, int2x3, bool>
    , IComparisonOperators<int2x3, int2x3, b32m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int2x3, int2x3, bool>.operator <(int2x3 left, int2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3, int2x3, bool>.operator >(int2x3 left, int2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3, int2x3, bool>.operator <=(int2x3 left, int2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x3, int2x3, bool>.operator >=(int2x3 left, int2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <(int2x3 left, int2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >(int2x3 left, int2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <=(int2x3 left, int2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >=(int2x3 left, int2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // int2x3

#region int2x4

public partial struct int2x4 : IComparable<int2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int2x4, int2x4, bool>
    , IComparisonOperators<int2x4, int2x4, b32m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int2x4, int2x4, bool>.operator <(int2x4 left, int2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4, int2x4, bool>.operator >(int2x4 left, int2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4, int2x4, bool>.operator <=(int2x4 left, int2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int2x4, int2x4, bool>.operator >=(int2x4 left, int2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <(int2x4 left, int2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >(int2x4 left, int2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <=(int2x4 left, int2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >=(int2x4 left, int2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // int2x4

#region int3x2

public partial struct int3x2 : IComparable<int3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int3x2, int3x2, bool>
    , IComparisonOperators<int3x2, int3x2, b32m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int3x2, int3x2, bool>.operator <(int3x2 left, int3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2, int3x2, bool>.operator >(int3x2 left, int3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2, int3x2, bool>.operator <=(int3x2 left, int3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x2, int3x2, bool>.operator >=(int3x2 left, int3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <(int3x2 left, int3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >(int3x2 left, int3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <=(int3x2 left, int3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >=(int3x2 left, int3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // int3x2

#region int3x3

public partial struct int3x3 : IComparable<int3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int3x3, int3x3, bool>
    , IComparisonOperators<int3x3, int3x3, b32m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int3x3, int3x3, bool>.operator <(int3x3 left, int3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3, int3x3, bool>.operator >(int3x3 left, int3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3, int3x3, bool>.operator <=(int3x3 left, int3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x3, int3x3, bool>.operator >=(int3x3 left, int3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <(int3x3 left, int3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >(int3x3 left, int3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <=(int3x3 left, int3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >=(int3x3 left, int3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // int3x3

#region int3x4

public partial struct int3x4 : IComparable<int3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int3x4, int3x4, bool>
    , IComparisonOperators<int3x4, int3x4, b32m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int3x4, int3x4, bool>.operator <(int3x4 left, int3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4, int3x4, bool>.operator >(int3x4 left, int3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4, int3x4, bool>.operator <=(int3x4 left, int3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int3x4, int3x4, bool>.operator >=(int3x4 left, int3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <(int3x4 left, int3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >(int3x4 left, int3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <=(int3x4 left, int3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >=(int3x4 left, int3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // int3x4

#region int4x2

public partial struct int4x2 : IComparable<int4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int4x2, int4x2, bool>
    , IComparisonOperators<int4x2, int4x2, b32m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int4x2, int4x2, bool>.operator <(int4x2 left, int4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2, int4x2, bool>.operator >(int4x2 left, int4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2, int4x2, bool>.operator <=(int4x2 left, int4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x2, int4x2, bool>.operator >=(int4x2 left, int4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <(int4x2 left, int4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >(int4x2 left, int4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <=(int4x2 left, int4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >=(int4x2 left, int4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // int4x2

#region int4x3

public partial struct int4x3 : IComparable<int4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int4x3, int4x3, bool>
    , IComparisonOperators<int4x3, int4x3, b32m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int4x3, int4x3, bool>.operator <(int4x3 left, int4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3, int4x3, bool>.operator >(int4x3 left, int4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3, int4x3, bool>.operator <=(int4x3 left, int4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x3, int4x3, bool>.operator >=(int4x3 left, int4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <(int4x3 left, int4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >(int4x3 left, int4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <=(int4x3 left, int4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >=(int4x3 left, int4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // int4x3

#region int4x4

public partial struct int4x4 : IComparable<int4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<int4x4, int4x4, bool>
    , IComparisonOperators<int4x4, int4x4, b32m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is int4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(int4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<int4x4, int4x4, bool>.operator <(int4x4 left, int4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4, int4x4, bool>.operator >(int4x4 left, int4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4, int4x4, bool>.operator <=(int4x4 left, int4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<int4x4, int4x4, bool>.operator >=(int4x4 left, int4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(int4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <(int4x4 left, int4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >(int4x4 left, int4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <=(int4x4 left, int4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >=(int4x4 left, int4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(int4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(int4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(int4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(int4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(int4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(int4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(int4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(int4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // int4x4

#region uint2x2

public partial struct uint2x2 : IComparable<uint2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint2x2, uint2x2, bool>
    , IComparisonOperators<uint2x2, uint2x2, b32m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint2x2, uint2x2, bool>.operator <(uint2x2 left, uint2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2, uint2x2, bool>.operator >(uint2x2 left, uint2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2, uint2x2, bool>.operator <=(uint2x2 left, uint2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x2, uint2x2, bool>.operator >=(uint2x2 left, uint2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <(uint2x2 left, uint2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >(uint2x2 left, uint2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <=(uint2x2 left, uint2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >=(uint2x2 left, uint2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // uint2x2

#region uint2x3

public partial struct uint2x3 : IComparable<uint2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint2x3, uint2x3, bool>
    , IComparisonOperators<uint2x3, uint2x3, b32m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint2x3, uint2x3, bool>.operator <(uint2x3 left, uint2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3, uint2x3, bool>.operator >(uint2x3 left, uint2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3, uint2x3, bool>.operator <=(uint2x3 left, uint2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x3, uint2x3, bool>.operator >=(uint2x3 left, uint2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <(uint2x3 left, uint2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >(uint2x3 left, uint2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <=(uint2x3 left, uint2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >=(uint2x3 left, uint2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // uint2x3

#region uint2x4

public partial struct uint2x4 : IComparable<uint2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint2x4, uint2x4, bool>
    , IComparisonOperators<uint2x4, uint2x4, b32m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint2x4, uint2x4, bool>.operator <(uint2x4 left, uint2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4, uint2x4, bool>.operator >(uint2x4 left, uint2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4, uint2x4, bool>.operator <=(uint2x4 left, uint2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint2x4, uint2x4, bool>.operator >=(uint2x4 left, uint2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <(uint2x4 left, uint2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >(uint2x4 left, uint2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <=(uint2x4 left, uint2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >=(uint2x4 left, uint2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // uint2x4

#region uint3x2

public partial struct uint3x2 : IComparable<uint3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint3x2, uint3x2, bool>
    , IComparisonOperators<uint3x2, uint3x2, b32m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint3x2, uint3x2, bool>.operator <(uint3x2 left, uint3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2, uint3x2, bool>.operator >(uint3x2 left, uint3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2, uint3x2, bool>.operator <=(uint3x2 left, uint3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x2, uint3x2, bool>.operator >=(uint3x2 left, uint3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <(uint3x2 left, uint3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >(uint3x2 left, uint3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <=(uint3x2 left, uint3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >=(uint3x2 left, uint3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // uint3x2

#region uint3x3

public partial struct uint3x3 : IComparable<uint3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint3x3, uint3x3, bool>
    , IComparisonOperators<uint3x3, uint3x3, b32m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint3x3, uint3x3, bool>.operator <(uint3x3 left, uint3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3, uint3x3, bool>.operator >(uint3x3 left, uint3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3, uint3x3, bool>.operator <=(uint3x3 left, uint3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x3, uint3x3, bool>.operator >=(uint3x3 left, uint3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <(uint3x3 left, uint3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >(uint3x3 left, uint3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <=(uint3x3 left, uint3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >=(uint3x3 left, uint3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // uint3x3

#region uint3x4

public partial struct uint3x4 : IComparable<uint3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint3x4, uint3x4, bool>
    , IComparisonOperators<uint3x4, uint3x4, b32m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint3x4, uint3x4, bool>.operator <(uint3x4 left, uint3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4, uint3x4, bool>.operator >(uint3x4 left, uint3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4, uint3x4, bool>.operator <=(uint3x4 left, uint3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint3x4, uint3x4, bool>.operator >=(uint3x4 left, uint3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <(uint3x4 left, uint3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >(uint3x4 left, uint3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <=(uint3x4 left, uint3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >=(uint3x4 left, uint3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // uint3x4

#region uint4x2

public partial struct uint4x2 : IComparable<uint4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint4x2, uint4x2, bool>
    , IComparisonOperators<uint4x2, uint4x2, b32m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint4x2, uint4x2, bool>.operator <(uint4x2 left, uint4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2, uint4x2, bool>.operator >(uint4x2 left, uint4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2, uint4x2, bool>.operator <=(uint4x2 left, uint4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x2, uint4x2, bool>.operator >=(uint4x2 left, uint4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <(uint4x2 left, uint4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >(uint4x2 left, uint4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <=(uint4x2 left, uint4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >=(uint4x2 left, uint4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // uint4x2

#region uint4x3

public partial struct uint4x3 : IComparable<uint4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint4x3, uint4x3, bool>
    , IComparisonOperators<uint4x3, uint4x3, b32m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint4x3, uint4x3, bool>.operator <(uint4x3 left, uint4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3, uint4x3, bool>.operator >(uint4x3 left, uint4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3, uint4x3, bool>.operator <=(uint4x3 left, uint4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x3, uint4x3, bool>.operator >=(uint4x3 left, uint4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <(uint4x3 left, uint4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >(uint4x3 left, uint4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <=(uint4x3 left, uint4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >=(uint4x3 left, uint4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // uint4x3

#region uint4x4

public partial struct uint4x4 : IComparable<uint4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<uint4x4, uint4x4, bool>
    , IComparisonOperators<uint4x4, uint4x4, b32m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is uint4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(uint4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<uint4x4, uint4x4, bool>.operator <(uint4x4 left, uint4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4, uint4x4, bool>.operator >(uint4x4 left, uint4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4, uint4x4, bool>.operator <=(uint4x4 left, uint4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<uint4x4, uint4x4, bool>.operator >=(uint4x4 left, uint4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(uint4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <(uint4x4 left, uint4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >(uint4x4 left, uint4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <=(uint4x4 left, uint4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >=(uint4x4 left, uint4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(uint4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(uint4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(uint4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(uint4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(uint4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(uint4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(uint4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(uint4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // uint4x4

#region long2x2

public partial struct long2x2 : IComparable<long2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long2x2, long2x2, bool>
    , IComparisonOperators<long2x2, long2x2, b64m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long2x2, long2x2, bool>.operator <(long2x2 left, long2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2, long2x2, bool>.operator >(long2x2 left, long2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2, long2x2, bool>.operator <=(long2x2 left, long2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x2, long2x2, bool>.operator >=(long2x2 left, long2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <(long2x2 left, long2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >(long2x2 left, long2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <=(long2x2 left, long2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >=(long2x2 left, long2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // long2x2

#region long2x3

public partial struct long2x3 : IComparable<long2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long2x3, long2x3, bool>
    , IComparisonOperators<long2x3, long2x3, b64m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long2x3, long2x3, bool>.operator <(long2x3 left, long2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3, long2x3, bool>.operator >(long2x3 left, long2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3, long2x3, bool>.operator <=(long2x3 left, long2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x3, long2x3, bool>.operator >=(long2x3 left, long2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <(long2x3 left, long2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >(long2x3 left, long2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <=(long2x3 left, long2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >=(long2x3 left, long2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // long2x3

#region long2x4

public partial struct long2x4 : IComparable<long2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long2x4, long2x4, bool>
    , IComparisonOperators<long2x4, long2x4, b64m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long2x4, long2x4, bool>.operator <(long2x4 left, long2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4, long2x4, bool>.operator >(long2x4 left, long2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4, long2x4, bool>.operator <=(long2x4 left, long2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long2x4, long2x4, bool>.operator >=(long2x4 left, long2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <(long2x4 left, long2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >(long2x4 left, long2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <=(long2x4 left, long2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >=(long2x4 left, long2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // long2x4

#region long3x2

public partial struct long3x2 : IComparable<long3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long3x2, long3x2, bool>
    , IComparisonOperators<long3x2, long3x2, b64m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long3x2, long3x2, bool>.operator <(long3x2 left, long3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2, long3x2, bool>.operator >(long3x2 left, long3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2, long3x2, bool>.operator <=(long3x2 left, long3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x2, long3x2, bool>.operator >=(long3x2 left, long3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <(long3x2 left, long3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >(long3x2 left, long3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <=(long3x2 left, long3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >=(long3x2 left, long3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // long3x2

#region long3x3

public partial struct long3x3 : IComparable<long3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long3x3, long3x3, bool>
    , IComparisonOperators<long3x3, long3x3, b64m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long3x3, long3x3, bool>.operator <(long3x3 left, long3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3, long3x3, bool>.operator >(long3x3 left, long3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3, long3x3, bool>.operator <=(long3x3 left, long3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x3, long3x3, bool>.operator >=(long3x3 left, long3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <(long3x3 left, long3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >(long3x3 left, long3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <=(long3x3 left, long3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >=(long3x3 left, long3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // long3x3

#region long3x4

public partial struct long3x4 : IComparable<long3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long3x4, long3x4, bool>
    , IComparisonOperators<long3x4, long3x4, b64m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long3x4, long3x4, bool>.operator <(long3x4 left, long3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4, long3x4, bool>.operator >(long3x4 left, long3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4, long3x4, bool>.operator <=(long3x4 left, long3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long3x4, long3x4, bool>.operator >=(long3x4 left, long3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <(long3x4 left, long3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >(long3x4 left, long3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <=(long3x4 left, long3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >=(long3x4 left, long3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // long3x4

#region long4x2

public partial struct long4x2 : IComparable<long4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long4x2, long4x2, bool>
    , IComparisonOperators<long4x2, long4x2, b64m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long4x2, long4x2, bool>.operator <(long4x2 left, long4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2, long4x2, bool>.operator >(long4x2 left, long4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2, long4x2, bool>.operator <=(long4x2 left, long4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x2, long4x2, bool>.operator >=(long4x2 left, long4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <(long4x2 left, long4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >(long4x2 left, long4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <=(long4x2 left, long4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >=(long4x2 left, long4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // long4x2

#region long4x3

public partial struct long4x3 : IComparable<long4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long4x3, long4x3, bool>
    , IComparisonOperators<long4x3, long4x3, b64m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long4x3, long4x3, bool>.operator <(long4x3 left, long4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3, long4x3, bool>.operator >(long4x3 left, long4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3, long4x3, bool>.operator <=(long4x3 left, long4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x3, long4x3, bool>.operator >=(long4x3 left, long4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <(long4x3 left, long4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >(long4x3 left, long4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <=(long4x3 left, long4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >=(long4x3 left, long4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // long4x3

#region long4x4

public partial struct long4x4 : IComparable<long4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<long4x4, long4x4, bool>
    , IComparisonOperators<long4x4, long4x4, b64m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is long4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(long4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<long4x4, long4x4, bool>.operator <(long4x4 left, long4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4, long4x4, bool>.operator >(long4x4 left, long4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4, long4x4, bool>.operator <=(long4x4 left, long4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<long4x4, long4x4, bool>.operator >=(long4x4 left, long4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(long4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <(long4x4 left, long4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >(long4x4 left, long4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <=(long4x4 left, long4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >=(long4x4 left, long4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(long4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(long4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(long4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(long4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(long4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(long4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(long4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(long4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // long4x4

#region ulong2x2

public partial struct ulong2x2 : IComparable<ulong2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong2x2, ulong2x2, bool>
    , IComparisonOperators<ulong2x2, ulong2x2, b64m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong2x2, ulong2x2, bool>.operator <(ulong2x2 left, ulong2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2, ulong2x2, bool>.operator >(ulong2x2 left, ulong2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2, ulong2x2, bool>.operator <=(ulong2x2 left, ulong2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x2, ulong2x2, bool>.operator >=(ulong2x2 left, ulong2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <(ulong2x2 left, ulong2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >(ulong2x2 left, ulong2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <=(ulong2x2 left, ulong2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >=(ulong2x2 left, ulong2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ulong2x2

#region ulong2x3

public partial struct ulong2x3 : IComparable<ulong2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong2x3, ulong2x3, bool>
    , IComparisonOperators<ulong2x3, ulong2x3, b64m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong2x3, ulong2x3, bool>.operator <(ulong2x3 left, ulong2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3, ulong2x3, bool>.operator >(ulong2x3 left, ulong2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3, ulong2x3, bool>.operator <=(ulong2x3 left, ulong2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x3, ulong2x3, bool>.operator >=(ulong2x3 left, ulong2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <(ulong2x3 left, ulong2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >(ulong2x3 left, ulong2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <=(ulong2x3 left, ulong2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >=(ulong2x3 left, ulong2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ulong2x3

#region ulong2x4

public partial struct ulong2x4 : IComparable<ulong2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong2x4, ulong2x4, bool>
    , IComparisonOperators<ulong2x4, ulong2x4, b64m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong2x4, ulong2x4, bool>.operator <(ulong2x4 left, ulong2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4, ulong2x4, bool>.operator >(ulong2x4 left, ulong2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4, ulong2x4, bool>.operator <=(ulong2x4 left, ulong2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong2x4, ulong2x4, bool>.operator >=(ulong2x4 left, ulong2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <(ulong2x4 left, ulong2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >(ulong2x4 left, ulong2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <=(ulong2x4 left, ulong2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >=(ulong2x4 left, ulong2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ulong2x4

#region ulong3x2

public partial struct ulong3x2 : IComparable<ulong3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong3x2, ulong3x2, bool>
    , IComparisonOperators<ulong3x2, ulong3x2, b64m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong3x2, ulong3x2, bool>.operator <(ulong3x2 left, ulong3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2, ulong3x2, bool>.operator >(ulong3x2 left, ulong3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2, ulong3x2, bool>.operator <=(ulong3x2 left, ulong3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x2, ulong3x2, bool>.operator >=(ulong3x2 left, ulong3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <(ulong3x2 left, ulong3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >(ulong3x2 left, ulong3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <=(ulong3x2 left, ulong3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >=(ulong3x2 left, ulong3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ulong3x2

#region ulong3x3

public partial struct ulong3x3 : IComparable<ulong3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong3x3, ulong3x3, bool>
    , IComparisonOperators<ulong3x3, ulong3x3, b64m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong3x3, ulong3x3, bool>.operator <(ulong3x3 left, ulong3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3, ulong3x3, bool>.operator >(ulong3x3 left, ulong3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3, ulong3x3, bool>.operator <=(ulong3x3 left, ulong3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x3, ulong3x3, bool>.operator >=(ulong3x3 left, ulong3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <(ulong3x3 left, ulong3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >(ulong3x3 left, ulong3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <=(ulong3x3 left, ulong3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >=(ulong3x3 left, ulong3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ulong3x3

#region ulong3x4

public partial struct ulong3x4 : IComparable<ulong3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong3x4, ulong3x4, bool>
    , IComparisonOperators<ulong3x4, ulong3x4, b64m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong3x4, ulong3x4, bool>.operator <(ulong3x4 left, ulong3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4, ulong3x4, bool>.operator >(ulong3x4 left, ulong3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4, ulong3x4, bool>.operator <=(ulong3x4 left, ulong3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong3x4, ulong3x4, bool>.operator >=(ulong3x4 left, ulong3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <(ulong3x4 left, ulong3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >(ulong3x4 left, ulong3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <=(ulong3x4 left, ulong3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >=(ulong3x4 left, ulong3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ulong3x4

#region ulong4x2

public partial struct ulong4x2 : IComparable<ulong4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong4x2, ulong4x2, bool>
    , IComparisonOperators<ulong4x2, ulong4x2, b64m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong4x2, ulong4x2, bool>.operator <(ulong4x2 left, ulong4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2, ulong4x2, bool>.operator >(ulong4x2 left, ulong4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2, ulong4x2, bool>.operator <=(ulong4x2 left, ulong4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x2, ulong4x2, bool>.operator >=(ulong4x2 left, ulong4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <(ulong4x2 left, ulong4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >(ulong4x2 left, ulong4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <=(ulong4x2 left, ulong4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >=(ulong4x2 left, ulong4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // ulong4x2

#region ulong4x3

public partial struct ulong4x3 : IComparable<ulong4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong4x3, ulong4x3, bool>
    , IComparisonOperators<ulong4x3, ulong4x3, b64m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong4x3, ulong4x3, bool>.operator <(ulong4x3 left, ulong4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3, ulong4x3, bool>.operator >(ulong4x3 left, ulong4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3, ulong4x3, bool>.operator <=(ulong4x3 left, ulong4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x3, ulong4x3, bool>.operator >=(ulong4x3 left, ulong4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <(ulong4x3 left, ulong4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >(ulong4x3 left, ulong4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <=(ulong4x3 left, ulong4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >=(ulong4x3 left, ulong4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // ulong4x3

#region ulong4x4

public partial struct ulong4x4 : IComparable<ulong4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<ulong4x4, ulong4x4, bool>
    , IComparisonOperators<ulong4x4, ulong4x4, b64m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is ulong4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(ulong4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<ulong4x4, ulong4x4, bool>.operator <(ulong4x4 left, ulong4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4, ulong4x4, bool>.operator >(ulong4x4 left, ulong4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4, ulong4x4, bool>.operator <=(ulong4x4 left, ulong4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<ulong4x4, ulong4x4, bool>.operator >=(ulong4x4 left, ulong4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(ulong4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <(ulong4x4 left, ulong4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >(ulong4x4 left, ulong4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <=(ulong4x4 left, ulong4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >=(ulong4x4 left, ulong4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(ulong4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(ulong4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(ulong4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(ulong4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(ulong4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(ulong4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(ulong4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(ulong4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // ulong4x4

#region half2x2

public partial struct half2x2 : IComparable<half2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half2x2, half2x2, bool>
    , IComparisonOperators<half2x2, half2x2, b16m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half2x2, half2x2, bool>.operator <(half2x2 left, half2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x2, half2x2, bool>.operator >(half2x2 left, half2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x2, half2x2, bool>.operator <=(half2x2 left, half2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x2, half2x2, bool>.operator >=(half2x2 left, half2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <(half2x2 left, half2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >(half2x2 left, half2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <=(half2x2 left, half2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >=(half2x2 left, half2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // half2x2

#region half2x3

public partial struct half2x3 : IComparable<half2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half2x3, half2x3, bool>
    , IComparisonOperators<half2x3, half2x3, b16m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half2x3, half2x3, bool>.operator <(half2x3 left, half2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x3, half2x3, bool>.operator >(half2x3 left, half2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x3, half2x3, bool>.operator <=(half2x3 left, half2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x3, half2x3, bool>.operator >=(half2x3 left, half2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <(half2x3 left, half2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >(half2x3 left, half2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <=(half2x3 left, half2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >=(half2x3 left, half2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // half2x3

#region half2x4

public partial struct half2x4 : IComparable<half2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half2x4, half2x4, bool>
    , IComparisonOperators<half2x4, half2x4, b16m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half2x4, half2x4, bool>.operator <(half2x4 left, half2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x4, half2x4, bool>.operator >(half2x4 left, half2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x4, half2x4, bool>.operator <=(half2x4 left, half2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half2x4, half2x4, bool>.operator >=(half2x4 left, half2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <(half2x4 left, half2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >(half2x4 left, half2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <=(half2x4 left, half2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >=(half2x4 left, half2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // half2x4

#region half3x2

public partial struct half3x2 : IComparable<half3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half3x2, half3x2, bool>
    , IComparisonOperators<half3x2, half3x2, b16m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half3x2, half3x2, bool>.operator <(half3x2 left, half3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x2, half3x2, bool>.operator >(half3x2 left, half3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x2, half3x2, bool>.operator <=(half3x2 left, half3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x2, half3x2, bool>.operator >=(half3x2 left, half3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <(half3x2 left, half3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >(half3x2 left, half3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <=(half3x2 left, half3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >=(half3x2 left, half3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // half3x2

#region half3x3

public partial struct half3x3 : IComparable<half3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half3x3, half3x3, bool>
    , IComparisonOperators<half3x3, half3x3, b16m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half3x3, half3x3, bool>.operator <(half3x3 left, half3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x3, half3x3, bool>.operator >(half3x3 left, half3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x3, half3x3, bool>.operator <=(half3x3 left, half3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x3, half3x3, bool>.operator >=(half3x3 left, half3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <(half3x3 left, half3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >(half3x3 left, half3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <=(half3x3 left, half3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >=(half3x3 left, half3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // half3x3

#region half3x4

public partial struct half3x4 : IComparable<half3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half3x4, half3x4, bool>
    , IComparisonOperators<half3x4, half3x4, b16m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half3x4, half3x4, bool>.operator <(half3x4 left, half3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x4, half3x4, bool>.operator >(half3x4 left, half3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x4, half3x4, bool>.operator <=(half3x4 left, half3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half3x4, half3x4, bool>.operator >=(half3x4 left, half3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <(half3x4 left, half3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >(half3x4 left, half3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <=(half3x4 left, half3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >=(half3x4 left, half3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // half3x4

#region half4x2

public partial struct half4x2 : IComparable<half4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half4x2, half4x2, bool>
    , IComparisonOperators<half4x2, half4x2, b16m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half4x2, half4x2, bool>.operator <(half4x2 left, half4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x2, half4x2, bool>.operator >(half4x2 left, half4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x2, half4x2, bool>.operator <=(half4x2 left, half4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x2, half4x2, bool>.operator >=(half4x2 left, half4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <(half4x2 left, half4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >(half4x2 left, half4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <=(half4x2 left, half4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >=(half4x2 left, half4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // half4x2

#region half4x3

public partial struct half4x3 : IComparable<half4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half4x3, half4x3, bool>
    , IComparisonOperators<half4x3, half4x3, b16m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half4x3, half4x3, bool>.operator <(half4x3 left, half4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x3, half4x3, bool>.operator >(half4x3 left, half4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x3, half4x3, bool>.operator <=(half4x3 left, half4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x3, half4x3, bool>.operator >=(half4x3 left, half4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <(half4x3 left, half4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >(half4x3 left, half4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <=(half4x3 left, half4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >=(half4x3 left, half4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // half4x3

#region half4x4

public partial struct half4x4 : IComparable<half4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<half4x4, half4x4, bool>
    , IComparisonOperators<half4x4, half4x4, b16m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is half4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(half4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<half4x4, half4x4, bool>.operator <(half4x4 left, half4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x4, half4x4, bool>.operator >(half4x4 left, half4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x4, half4x4, bool>.operator <=(half4x4 left, half4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<half4x4, half4x4, bool>.operator >=(half4x4 left, half4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(half4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <(half4x4 left, half4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >(half4x4 left, half4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <=(half4x4 left, half4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >=(half4x4 left, half4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(half4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(half4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(half4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(half4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(half4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(half4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(half4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(half4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // half4x4

#region b16m2x2

public partial struct b16m2x2 : IComparable<b16m2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m2x2, b16m2x2, bool>
    , IComparisonOperators<b16m2x2, b16m2x2, b16m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m2x2, b16m2x2, bool>.operator <(b16m2x2 left, b16m2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x2, b16m2x2, bool>.operator >(b16m2x2 left, b16m2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x2, b16m2x2, bool>.operator <=(b16m2x2 left, b16m2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x2, b16m2x2, bool>.operator >=(b16m2x2 left, b16m2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <(b16m2x2 left, b16m2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >(b16m2x2 left, b16m2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator <=(b16m2x2 left, b16m2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m2x2 operator >=(b16m2x2 left, b16m2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b16m2x2

#region b16m2x3

public partial struct b16m2x3 : IComparable<b16m2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m2x3, b16m2x3, bool>
    , IComparisonOperators<b16m2x3, b16m2x3, b16m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m2x3, b16m2x3, bool>.operator <(b16m2x3 left, b16m2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x3, b16m2x3, bool>.operator >(b16m2x3 left, b16m2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x3, b16m2x3, bool>.operator <=(b16m2x3 left, b16m2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x3, b16m2x3, bool>.operator >=(b16m2x3 left, b16m2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <(b16m2x3 left, b16m2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >(b16m2x3 left, b16m2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator <=(b16m2x3 left, b16m2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m2x3 operator >=(b16m2x3 left, b16m2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b16m2x3

#region b16m2x4

public partial struct b16m2x4 : IComparable<b16m2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m2x4, b16m2x4, bool>
    , IComparisonOperators<b16m2x4, b16m2x4, b16m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m2x4, b16m2x4, bool>.operator <(b16m2x4 left, b16m2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x4, b16m2x4, bool>.operator >(b16m2x4 left, b16m2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x4, b16m2x4, bool>.operator <=(b16m2x4 left, b16m2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m2x4, b16m2x4, bool>.operator >=(b16m2x4 left, b16m2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <(b16m2x4 left, b16m2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >(b16m2x4 left, b16m2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator <=(b16m2x4 left, b16m2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m2x4 operator >=(b16m2x4 left, b16m2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b16m2x4

#region b16m3x2

public partial struct b16m3x2 : IComparable<b16m3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m3x2, b16m3x2, bool>
    , IComparisonOperators<b16m3x2, b16m3x2, b16m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m3x2, b16m3x2, bool>.operator <(b16m3x2 left, b16m3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x2, b16m3x2, bool>.operator >(b16m3x2 left, b16m3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x2, b16m3x2, bool>.operator <=(b16m3x2 left, b16m3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x2, b16m3x2, bool>.operator >=(b16m3x2 left, b16m3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <(b16m3x2 left, b16m3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >(b16m3x2 left, b16m3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator <=(b16m3x2 left, b16m3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m3x2 operator >=(b16m3x2 left, b16m3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b16m3x2

#region b16m3x3

public partial struct b16m3x3 : IComparable<b16m3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m3x3, b16m3x3, bool>
    , IComparisonOperators<b16m3x3, b16m3x3, b16m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m3x3, b16m3x3, bool>.operator <(b16m3x3 left, b16m3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x3, b16m3x3, bool>.operator >(b16m3x3 left, b16m3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x3, b16m3x3, bool>.operator <=(b16m3x3 left, b16m3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x3, b16m3x3, bool>.operator >=(b16m3x3 left, b16m3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <(b16m3x3 left, b16m3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >(b16m3x3 left, b16m3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator <=(b16m3x3 left, b16m3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m3x3 operator >=(b16m3x3 left, b16m3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b16m3x3

#region b16m3x4

public partial struct b16m3x4 : IComparable<b16m3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m3x4, b16m3x4, bool>
    , IComparisonOperators<b16m3x4, b16m3x4, b16m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m3x4, b16m3x4, bool>.operator <(b16m3x4 left, b16m3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x4, b16m3x4, bool>.operator >(b16m3x4 left, b16m3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x4, b16m3x4, bool>.operator <=(b16m3x4 left, b16m3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m3x4, b16m3x4, bool>.operator >=(b16m3x4 left, b16m3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <(b16m3x4 left, b16m3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >(b16m3x4 left, b16m3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator <=(b16m3x4 left, b16m3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m3x4 operator >=(b16m3x4 left, b16m3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b16m3x4

#region b16m4x2

public partial struct b16m4x2 : IComparable<b16m4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m4x2, b16m4x2, bool>
    , IComparisonOperators<b16m4x2, b16m4x2, b16m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m4x2, b16m4x2, bool>.operator <(b16m4x2 left, b16m4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x2, b16m4x2, bool>.operator >(b16m4x2 left, b16m4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x2, b16m4x2, bool>.operator <=(b16m4x2 left, b16m4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x2, b16m4x2, bool>.operator >=(b16m4x2 left, b16m4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <(b16m4x2 left, b16m4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >(b16m4x2 left, b16m4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator <=(b16m4x2 left, b16m4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b16m4x2 operator >=(b16m4x2 left, b16m4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b16m4x2

#region b16m4x3

public partial struct b16m4x3 : IComparable<b16m4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m4x3, b16m4x3, bool>
    , IComparisonOperators<b16m4x3, b16m4x3, b16m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m4x3, b16m4x3, bool>.operator <(b16m4x3 left, b16m4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x3, b16m4x3, bool>.operator >(b16m4x3 left, b16m4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x3, b16m4x3, bool>.operator <=(b16m4x3 left, b16m4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x3, b16m4x3, bool>.operator >=(b16m4x3 left, b16m4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <(b16m4x3 left, b16m4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >(b16m4x3 left, b16m4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator <=(b16m4x3 left, b16m4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b16m4x3 operator >=(b16m4x3 left, b16m4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b16m4x3

#region b16m4x4

public partial struct b16m4x4 : IComparable<b16m4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b16m4x4, b16m4x4, bool>
    , IComparisonOperators<b16m4x4, b16m4x4, b16m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b16m4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b16m4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b16m4x4, b16m4x4, bool>.operator <(b16m4x4 left, b16m4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x4, b16m4x4, bool>.operator >(b16m4x4 left, b16m4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x4, b16m4x4, bool>.operator <=(b16m4x4 left, b16m4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b16m4x4, b16m4x4, bool>.operator >=(b16m4x4 left, b16m4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b16m4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <(b16m4x4 left, b16m4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >(b16m4x4 left, b16m4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator <=(b16m4x4 left, b16m4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b16m4x4 operator >=(b16m4x4 left, b16m4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b16m4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b16m4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b16m4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b16m4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b16m4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b16m4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b16m4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b16m4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b16m4x4

#region b32m2x2

public partial struct b32m2x2 : IComparable<b32m2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m2x2, b32m2x2, bool>
    , IComparisonOperators<b32m2x2, b32m2x2, b32m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m2x2, b32m2x2, bool>.operator <(b32m2x2 left, b32m2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2, b32m2x2, bool>.operator >(b32m2x2 left, b32m2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2, b32m2x2, bool>.operator <=(b32m2x2 left, b32m2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x2, b32m2x2, bool>.operator >=(b32m2x2 left, b32m2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <(b32m2x2 left, b32m2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >(b32m2x2 left, b32m2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator <=(b32m2x2 left, b32m2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m2x2 operator >=(b32m2x2 left, b32m2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b32m2x2

#region b32m2x3

public partial struct b32m2x3 : IComparable<b32m2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m2x3, b32m2x3, bool>
    , IComparisonOperators<b32m2x3, b32m2x3, b32m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m2x3, b32m2x3, bool>.operator <(b32m2x3 left, b32m2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3, b32m2x3, bool>.operator >(b32m2x3 left, b32m2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3, b32m2x3, bool>.operator <=(b32m2x3 left, b32m2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x3, b32m2x3, bool>.operator >=(b32m2x3 left, b32m2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <(b32m2x3 left, b32m2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >(b32m2x3 left, b32m2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator <=(b32m2x3 left, b32m2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m2x3 operator >=(b32m2x3 left, b32m2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b32m2x3

#region b32m2x4

public partial struct b32m2x4 : IComparable<b32m2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m2x4, b32m2x4, bool>
    , IComparisonOperators<b32m2x4, b32m2x4, b32m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m2x4, b32m2x4, bool>.operator <(b32m2x4 left, b32m2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4, b32m2x4, bool>.operator >(b32m2x4 left, b32m2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4, b32m2x4, bool>.operator <=(b32m2x4 left, b32m2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m2x4, b32m2x4, bool>.operator >=(b32m2x4 left, b32m2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <(b32m2x4 left, b32m2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >(b32m2x4 left, b32m2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator <=(b32m2x4 left, b32m2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m2x4 operator >=(b32m2x4 left, b32m2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b32m2x4

#region b32m3x2

public partial struct b32m3x2 : IComparable<b32m3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m3x2, b32m3x2, bool>
    , IComparisonOperators<b32m3x2, b32m3x2, b32m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m3x2, b32m3x2, bool>.operator <(b32m3x2 left, b32m3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2, b32m3x2, bool>.operator >(b32m3x2 left, b32m3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2, b32m3x2, bool>.operator <=(b32m3x2 left, b32m3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x2, b32m3x2, bool>.operator >=(b32m3x2 left, b32m3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <(b32m3x2 left, b32m3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >(b32m3x2 left, b32m3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator <=(b32m3x2 left, b32m3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m3x2 operator >=(b32m3x2 left, b32m3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b32m3x2

#region b32m3x3

public partial struct b32m3x3 : IComparable<b32m3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m3x3, b32m3x3, bool>
    , IComparisonOperators<b32m3x3, b32m3x3, b32m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m3x3, b32m3x3, bool>.operator <(b32m3x3 left, b32m3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3, b32m3x3, bool>.operator >(b32m3x3 left, b32m3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3, b32m3x3, bool>.operator <=(b32m3x3 left, b32m3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x3, b32m3x3, bool>.operator >=(b32m3x3 left, b32m3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <(b32m3x3 left, b32m3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >(b32m3x3 left, b32m3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator <=(b32m3x3 left, b32m3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m3x3 operator >=(b32m3x3 left, b32m3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b32m3x3

#region b32m3x4

public partial struct b32m3x4 : IComparable<b32m3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m3x4, b32m3x4, bool>
    , IComparisonOperators<b32m3x4, b32m3x4, b32m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m3x4, b32m3x4, bool>.operator <(b32m3x4 left, b32m3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4, b32m3x4, bool>.operator >(b32m3x4 left, b32m3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4, b32m3x4, bool>.operator <=(b32m3x4 left, b32m3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m3x4, b32m3x4, bool>.operator >=(b32m3x4 left, b32m3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <(b32m3x4 left, b32m3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >(b32m3x4 left, b32m3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator <=(b32m3x4 left, b32m3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m3x4 operator >=(b32m3x4 left, b32m3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b32m3x4

#region b32m4x2

public partial struct b32m4x2 : IComparable<b32m4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m4x2, b32m4x2, bool>
    , IComparisonOperators<b32m4x2, b32m4x2, b32m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m4x2, b32m4x2, bool>.operator <(b32m4x2 left, b32m4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2, b32m4x2, bool>.operator >(b32m4x2 left, b32m4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2, b32m4x2, bool>.operator <=(b32m4x2 left, b32m4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x2, b32m4x2, bool>.operator >=(b32m4x2 left, b32m4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <(b32m4x2 left, b32m4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >(b32m4x2 left, b32m4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator <=(b32m4x2 left, b32m4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b32m4x2 operator >=(b32m4x2 left, b32m4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b32m4x2

#region b32m4x3

public partial struct b32m4x3 : IComparable<b32m4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m4x3, b32m4x3, bool>
    , IComparisonOperators<b32m4x3, b32m4x3, b32m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m4x3, b32m4x3, bool>.operator <(b32m4x3 left, b32m4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3, b32m4x3, bool>.operator >(b32m4x3 left, b32m4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3, b32m4x3, bool>.operator <=(b32m4x3 left, b32m4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x3, b32m4x3, bool>.operator >=(b32m4x3 left, b32m4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <(b32m4x3 left, b32m4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >(b32m4x3 left, b32m4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator <=(b32m4x3 left, b32m4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b32m4x3 operator >=(b32m4x3 left, b32m4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b32m4x3

#region b32m4x4

public partial struct b32m4x4 : IComparable<b32m4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b32m4x4, b32m4x4, bool>
    , IComparisonOperators<b32m4x4, b32m4x4, b32m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b32m4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b32m4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b32m4x4, b32m4x4, bool>.operator <(b32m4x4 left, b32m4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4, b32m4x4, bool>.operator >(b32m4x4 left, b32m4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4, b32m4x4, bool>.operator <=(b32m4x4 left, b32m4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b32m4x4, b32m4x4, bool>.operator >=(b32m4x4 left, b32m4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b32m4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <(b32m4x4 left, b32m4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >(b32m4x4 left, b32m4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator <=(b32m4x4 left, b32m4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b32m4x4 operator >=(b32m4x4 left, b32m4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b32m4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b32m4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b32m4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b32m4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b32m4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b32m4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b32m4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b32m4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b32m4x4

#region b64m2x2

public partial struct b64m2x2 : IComparable<b64m2x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m2x2, b64m2x2, bool>
    , IComparisonOperators<b64m2x2, b64m2x2, b64m2x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m2x2, b64m2x2, bool>.operator <(b64m2x2 left, b64m2x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2, b64m2x2, bool>.operator >(b64m2x2 left, b64m2x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2, b64m2x2, bool>.operator <=(b64m2x2 left, b64m2x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x2, b64m2x2, bool>.operator >=(b64m2x2 left, b64m2x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m2x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <(b64m2x2 left, b64m2x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >(b64m2x2 left, b64m2x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator <=(b64m2x2 left, b64m2x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m2x2 operator >=(b64m2x2 left, b64m2x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m2x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m2x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m2x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m2x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m2x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m2x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m2x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m2x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b64m2x2

#region b64m2x3

public partial struct b64m2x3 : IComparable<b64m2x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m2x3, b64m2x3, bool>
    , IComparisonOperators<b64m2x3, b64m2x3, b64m2x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m2x3, b64m2x3, bool>.operator <(b64m2x3 left, b64m2x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3, b64m2x3, bool>.operator >(b64m2x3 left, b64m2x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3, b64m2x3, bool>.operator <=(b64m2x3 left, b64m2x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x3, b64m2x3, bool>.operator >=(b64m2x3 left, b64m2x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m2x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <(b64m2x3 left, b64m2x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >(b64m2x3 left, b64m2x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator <=(b64m2x3 left, b64m2x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m2x3 operator >=(b64m2x3 left, b64m2x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m2x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m2x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m2x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m2x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m2x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m2x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m2x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m2x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b64m2x3

#region b64m2x4

public partial struct b64m2x4 : IComparable<b64m2x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m2x4, b64m2x4, bool>
    , IComparisonOperators<b64m2x4, b64m2x4, b64m2x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m2x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m2x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m2x4, b64m2x4, bool>.operator <(b64m2x4 left, b64m2x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4, b64m2x4, bool>.operator >(b64m2x4 left, b64m2x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4, b64m2x4, bool>.operator <=(b64m2x4 left, b64m2x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m2x4, b64m2x4, bool>.operator >=(b64m2x4 left, b64m2x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m2x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <(b64m2x4 left, b64m2x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >(b64m2x4 left, b64m2x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator <=(b64m2x4 left, b64m2x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m2x4 operator >=(b64m2x4 left, b64m2x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m2x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m2x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m2x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m2x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m2x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m2x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m2x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m2x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b64m2x4

#region b64m3x2

public partial struct b64m3x2 : IComparable<b64m3x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m3x2, b64m3x2, bool>
    , IComparisonOperators<b64m3x2, b64m3x2, b64m3x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m3x2, b64m3x2, bool>.operator <(b64m3x2 left, b64m3x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2, b64m3x2, bool>.operator >(b64m3x2 left, b64m3x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2, b64m3x2, bool>.operator <=(b64m3x2 left, b64m3x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x2, b64m3x2, bool>.operator >=(b64m3x2 left, b64m3x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m3x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <(b64m3x2 left, b64m3x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >(b64m3x2 left, b64m3x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator <=(b64m3x2 left, b64m3x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m3x2 operator >=(b64m3x2 left, b64m3x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m3x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m3x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m3x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m3x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m3x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m3x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m3x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m3x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b64m3x2

#region b64m3x3

public partial struct b64m3x3 : IComparable<b64m3x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m3x3, b64m3x3, bool>
    , IComparisonOperators<b64m3x3, b64m3x3, b64m3x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m3x3, b64m3x3, bool>.operator <(b64m3x3 left, b64m3x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3, b64m3x3, bool>.operator >(b64m3x3 left, b64m3x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3, b64m3x3, bool>.operator <=(b64m3x3 left, b64m3x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x3, b64m3x3, bool>.operator >=(b64m3x3 left, b64m3x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m3x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <(b64m3x3 left, b64m3x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >(b64m3x3 left, b64m3x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator <=(b64m3x3 left, b64m3x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m3x3 operator >=(b64m3x3 left, b64m3x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m3x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m3x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m3x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m3x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m3x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m3x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m3x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m3x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b64m3x3

#region b64m3x4

public partial struct b64m3x4 : IComparable<b64m3x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m3x4, b64m3x4, bool>
    , IComparisonOperators<b64m3x4, b64m3x4, b64m3x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m3x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m3x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m3x4, b64m3x4, bool>.operator <(b64m3x4 left, b64m3x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4, b64m3x4, bool>.operator >(b64m3x4 left, b64m3x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4, b64m3x4, bool>.operator <=(b64m3x4 left, b64m3x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m3x4, b64m3x4, bool>.operator >=(b64m3x4 left, b64m3x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m3x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <(b64m3x4 left, b64m3x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >(b64m3x4 left, b64m3x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator <=(b64m3x4 left, b64m3x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m3x4 operator >=(b64m3x4 left, b64m3x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m3x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m3x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m3x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m3x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m3x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m3x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m3x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m3x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b64m3x4

#region b64m4x2

public partial struct b64m4x2 : IComparable<b64m4x2>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m4x2, b64m4x2, bool>
    , IComparisonOperators<b64m4x2, b64m4x2, b64m4x2>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x2 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x2)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m4x2, b64m4x2, bool>.operator <(b64m4x2 left, b64m4x2 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2, b64m4x2, bool>.operator >(b64m4x2 left, b64m4x2 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2, b64m4x2, bool>.operator <=(b64m4x2 left, b64m4x2 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x2, b64m4x2, bool>.operator >=(b64m4x2 left, b64m4x2 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m4x2 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <(b64m4x2 left, b64m4x2 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >(b64m4x2 left, b64m4x2 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator <=(b64m4x2 left, b64m4x2 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1);
    [MethodImpl(256 | 512)]
    public static b64m4x2 operator >=(b64m4x2 left, b64m4x2 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m4x2 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m4x2 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m4x2 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m4x2 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m4x2 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m4x2 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m4x2 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m4x2 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1);
}

#endregion // b64m4x2

#region b64m4x3

public partial struct b64m4x3 : IComparable<b64m4x3>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m4x3, b64m4x3, bool>
    , IComparisonOperators<b64m4x3, b64m4x3, b64m4x3>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x3 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x3)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m4x3, b64m4x3, bool>.operator <(b64m4x3 left, b64m4x3 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3, b64m4x3, bool>.operator >(b64m4x3 left, b64m4x3 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3, b64m4x3, bool>.operator <=(b64m4x3 left, b64m4x3 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x3, b64m4x3, bool>.operator >=(b64m4x3 left, b64m4x3 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m4x3 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <(b64m4x3 left, b64m4x3 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >(b64m4x3 left, b64m4x3 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator <=(b64m4x3 left, b64m4x3 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2);
    [MethodImpl(256 | 512)]
    public static b64m4x3 operator >=(b64m4x3 left, b64m4x3 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m4x3 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m4x3 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m4x3 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m4x3 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m4x3 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m4x3 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m4x3 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m4x3 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2);
}

#endregion // b64m4x3

#region b64m4x4

public partial struct b64m4x4 : IComparable<b64m4x4>, IComparable
    #if NET8_0_OR_GREATER
    , IComparisonOperators<b64m4x4, b64m4x4, bool>
    , IComparisonOperators<b64m4x4, b64m4x4, b64m4x4>
    #endif
{
    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is b64m4x4 other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(b64m4x4)}");
    }

    #if NET8_0_OR_GREATER
    static bool IComparisonOperators<b64m4x4, b64m4x4, bool>.operator <(b64m4x4 left, b64m4x4 right) => 
        left.LessThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4, b64m4x4, bool>.operator >(b64m4x4 left, b64m4x4 right) => 
        left.GreaterThanAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4, b64m4x4, bool>.operator <=(b64m4x4 left, b64m4x4 right) => 
        left.LessThanOrEqualAll(right);
    [MethodImpl(256 | 512)]
    static bool IComparisonOperators<b64m4x4, b64m4x4, bool>.operator >=(b64m4x4 left, b64m4x4 right) => 
        left.GreaterThanOrEqualAll(right);
    #endif

    [MethodImpl(256 | 512)]
    public int CompareTo(b64m4x4 other)
    {
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        { if (c0.CompareTo(other.c0) is var r and not 0) return r; }
        return 0;
    }

    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <(b64m4x4 left, b64m4x4 right) =>
        new(left.c0 < right.c0, left.c1 < right.c1, left.c2 < right.c2, left.c3 < right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >(b64m4x4 left, b64m4x4 right) =>
        new(left.c0 > right.c0, left.c1 > right.c1, left.c2 > right.c2, left.c3 > right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator <=(b64m4x4 left, b64m4x4 right) =>
        new(left.c0 <= right.c0, left.c1 <= right.c1, left.c2 <= right.c2, left.c3 <= right.c3);
    [MethodImpl(256 | 512)]
    public static b64m4x4 operator >=(b64m4x4 left, b64m4x4 right) =>
        new(left.c0 >= right.c0, left.c1 >= right.c1, left.c2 >= right.c2, left.c3 >= right.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAll(b64m4x4 other) => c0.LessThanAll(other.c0) && c1.LessThanAll(other.c1) && c2.LessThanAll(other.c2) && c3.LessThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAll(b64m4x4 other) => c0.GreaterThanAll(other.c0) && c1.GreaterThanAll(other.c1) && c2.GreaterThanAll(other.c2) && c3.GreaterThanAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAll(b64m4x4 other) => c0.LessThanOrEqualAll(other.c0) && c1.LessThanOrEqualAll(other.c1) && c2.LessThanOrEqualAll(other.c2) && c3.LessThanOrEqualAll(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAll(b64m4x4 other) => c0.GreaterThanOrEqualAll(other.c0) && c1.GreaterThanOrEqualAll(other.c1) && c2.GreaterThanOrEqualAll(other.c2) && c3.GreaterThanOrEqualAll(other.c3);

    [MethodImpl(256 | 512)]
    public bool LessThanAny(b64m4x4 other) => c0.LessThanAny(other.c0) || c1.LessThanAny(other.c1) || c2.LessThanAny(other.c2) || c3.LessThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanAny(b64m4x4 other) => c0.GreaterThanAny(other.c0) || c1.GreaterThanAny(other.c1) || c2.GreaterThanAny(other.c2) || c3.GreaterThanAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool LessThanOrEqualAny(b64m4x4 other) => c0.LessThanOrEqualAny(other.c0) || c1.LessThanOrEqualAny(other.c1) || c2.LessThanOrEqualAny(other.c2) || c3.LessThanOrEqualAny(other.c3);
    [MethodImpl(256 | 512)]
    public bool GreaterThanOrEqualAny(b64m4x4 other) => c0.GreaterThanOrEqualAny(other.c0) || c1.GreaterThanOrEqualAny(other.c1) || c2.GreaterThanOrEqualAny(other.c2) || c3.GreaterThanOrEqualAny(other.c3);
}

#endregion // b64m4x4
