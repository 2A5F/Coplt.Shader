// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region quaternion

public partial struct quaternion
{
    public float4 value;

    public static quaternion Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, 1.0f);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion(float x, float y, float z, float w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion(float4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion(float4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a float3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The float3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion(float3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (uint)(u.x.asu() & 0x80000000);
        var t = (v.y + ((uint)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new uint4((uint)(u_sign >> 31)).asf();
        var t_mask = new int4((int)(t.asi() >> 31)).asf();

        var tr = (1.0f + u.x.abs());

        var sign_flips =
            new uint4(default, 0x80000000, 0x80000000, 0x80000000).asf()
            ^ (u_mask & new uint4(default, 0x80000000, default, 0x80000000).asf())
            ^ (t_mask & new uint4(0x80000000, 0x80000000, 0x80000000, default).asf());

        value = new float4(tr, u.y, w.x, v.z) + (new float4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal float4x4 matrix</summary>
    /// <param name="m">The float4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion(float4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (uint)(u.x.asu() & 0x80000000);
        var t = (v.y + ((uint)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new uint4((uint)(u_sign >> 31)).asf();
        var t_mask = new int4((int)(t.asi() >> 31)).asf();

        var tr = (1.0f + u.x.abs());

        var sign_flips =
            new uint4(default, 0x80000000, 0x80000000, 0x80000000).asf()
            ^ (u_mask & new uint4(default, 0x80000000, default, 0x80000000).asf())
            ^ (t_mask & new uint4(0x80000000, 0x80000000, 0x80000000, default).asf());

        value = new float4(tr, u.y, w.x, v.z) + (new float4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion AxisAngle(float3 axis, float angle)
    {
        math.sincos((0.5f * angle), out var sina, out var cosa);
        return new(new float4(axis * sina, cosa));
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerXYZ(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(-1.0f, 1.0f, -1.0f, 1.0f)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerXZY(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(1.0f, 1.0f, -1.0f, -1.0f)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerYXZ(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(-1.0f, 1.0f, 1.0f, -1.0f)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerYZX(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(-1.0f, -1.0f, 1.0f, 1.0f)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerZXY(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(1.0f, -1.0f, -1.0f, 1.0f)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A float3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion EulerZYX(float3 xyz)
    {
        var (s, c) = (xyz * 0.5f).sincos();
        return new(
            new float4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new float4(c.xyz, s.x) * new float4(1.0f, -1.0f, 1.0f, -1.0f)
        );
    }

    /// <summary>Returns a quaternion that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion RotateX(float angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5f));
        return new(sina, default, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion RotateY(float angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5f));
        return new(default, sina, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the z-axis by a given number of radians.</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion RotateZ(float angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5f));
        return new(default, default, sina, cosa);
    }

    /// <summary>
    /// Returns a quaternion view rotation given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="quaternion.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation</returns>
    [MethodImpl(256 | 512)]
    public static quaternion LookRotation(float3 forward, float3 up)
    {
        var t = up.cross(forward).normalize();
        return new(new float3x3(t, forward.cross(t), forward));
    }

    /// <summary>
    /// Returns a quaternion view rotation given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation or the identity quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion LookRotationSafe(float3 forward, float3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<float>() && mx < math.MaxRotateSafe<float>()
             && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        return accept
            ? new quaternion(new float3x3(t, forward.cross(t), forward))
            : new quaternion(default, default, default, 1.0f);
    }
}

public static partial class math
{
    /// <summary>Returns the conjugate of a quaternion value</summary>
    /// <param name="q">The quaternion to conjugate</param>
    /// <returns>The conjugate of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion conjugate(this quaternion q) => 
        new(q.value * new float4(-1.0f, -1.0f, -1.0f, 1.0f));

    /// <summary>Returns the inverse of a quaternion value</summary>
    /// <param name="q">The quaternion to invert</param>
    /// <returns>The quaternion inverse of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion inverse(this quaternion q) => 
        new(q.dot(q).rcp() * q.value *  new float4(-1.0f, -1.0f, -1.0f, 1.0f));

    [MethodImpl(256 | 512)]
    public static float dot(this quaternion a, quaternion b) => a.value.dot(b.value);

    [MethodImpl(256 | 512)]
    public static float length(this quaternion q) => q.lengthsq().sqrt();

    [MethodImpl(256 | 512)]
    public static float lengthsq(this quaternion q) => q.dot(q);

    [MethodImpl(256 | 512)]
    public static quaternion normalize(this quaternion q) => new(q.dot(q).rsqrt() * q.value);

    [MethodImpl(256 | 512)]
    public static quaternion normalizesafe(this quaternion q)
    {
        var len = q.lengthsq();
        if (len > MinNormal<float>()) return quaternion.Identity;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion normalizesafe(this quaternion q, quaternion defaultValue)
    {
        var len = q.lengthsq();
        if (len > MinNormal<float>()) return defaultValue;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion unitexp(this quaternion q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new float4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len));
    }

    [MethodImpl(256 | 512)]
    public static quaternion exp(this quaternion q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new float4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len) * q.value.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static quaternion unitlog(this quaternion q)
    {
        var w = q.value.w.clamp(-1.0f, 1.0f);
        var s = (acos(w) * rsqrt(1.0f - w*w));
        return new(new float4(q.value.xyz * s, default));
    }

    [MethodImpl(256 | 512)]
    public static quaternion log(this quaternion q)
    {
        var v_len_sq = q.value.xyz.lengthsq();
        var q_len_sq = v_len_sq + q.value.w * q.value.w;

        var s = (acos(clamp(q.value.w * q_len_sq.rsqrt(), -1.0f, 1.0f)) * v_len_sq.rsqrt());
        return new(new float4(q.value.xyz * s, (0.5f * q_len_sq.log())));
    }

    [MethodImpl(256 | 512)]
    public static quaternion mul(this quaternion a, quaternion b) => new(
        a.value.wwww * b.value + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) 
        * new float4(1.0f, 1.0f, 1.0f, -1.0f) - a.value.zxyz * b.value.yzxz
    );

    [MethodImpl(256 | 512)]
    public static float3 mul(this quaternion q, float3 v)
    {
        var t = 2.0f * q.value.xyz.cross(v);
        return v + q.value.w * t + q.value.xyz.cross(t);
    }

    [MethodImpl(256 | 512)]
    public static float3 rotate(this quaternion q, float3 v) => mul(q, v);

    [MethodImpl(256 | 512)]
    public static quaternion nlerp(this float t, quaternion q1, quaternion q2) => 
        normalize(q1.value + t * (chgsign(q2.value, dot(q1, q2)) - q1.value));
    
    [MethodImpl(256 | 512)]
    public static quaternion slerp(this float t, quaternion q1, quaternion q2)
    {
        var dt = dot(q1, q2);
        if (dt < 0.0f)
        {
            dt = -dt;
            q2.value = -q2.value;
        }

        if (dt < 0.9995f)
        {
            var angle = dt.acos();
            var s = (rsqrt(1.0f - dt * dt));    // 1.0f / sin(angle)
            var w1 = (sin(angle * (1.0f - t)) * s);
            var w2 = (sin(angle * t) * s);
            return new quaternion(q1.value * w1 + q2.value * w2);
        }
        else
        {
            // if the angle is small, use linear interpolation
            return t.nlerp(q1, q2);
        }
    }
    
    [MethodImpl(256 | 512)]
    public static float angle(this quaternion q1, quaternion q2)
    {
        var diff = q1.conjugate().mul(q2).normalize().value.xyz.length().asin();
        return (diff + diff);
    }
    
    [MethodImpl(256 | 512)]
    public static quaternion rotation(this float3x3 m)
    {
        var det = m.determinant();
        if (math.abs(1f - det) < svd.k_EpsilonDeterminant_float)
            return new(m);

        if (det.abs() > svd.k_EpsilonDeterminant_float)
        {
            var tmp = m * new float3(m.c0.lengthsq(), m.c1.lengthsq(), m.c2.lengthsq()).rsqrt();
            if (math.abs(1f - math.determinant(tmp)) < svd.k_EpsilonDeterminant_float)
                return new(tmp);
        }

        return svd.svdRotation(m);
    }
    
    [MethodImpl(256 | 512)]
    public static float3x3 adj(this float3x3 m, out float det)
    {
        float3x3 adjT;
        adjT.c0 = m.c1.cross(m.c2);
        adjT.c1 = m.c2.cross(m.c0);
        adjT.c2 = m.c0.cross(m.c1);
        det = m.c0.dot(adjT.c0);

        return adjT.transpose();
    }
    
    [MethodImpl(256 | 512)]
    public static bool adj(this float3x3 m, out float3x3 i)
    {
        var epsilon = 1e-30f;
        return m.adj(out i, epsilon);
    }

    [MethodImpl(256 | 512)]
    public static bool adj(this float3x3 m, out float3x3 i, float epsilon)
    {
        i = adj(m, out float det);
        var c = det.abs() > epsilon;
        var detInv = c ? det.rcp() : new float3(1.0f) ;
        i = detInv * i;
        return c;
    }
}

#region svd

internal static partial class svd
{
    public static float k_EpsilonDeterminant_float
    {
        [MethodImpl(256 | 512)]
        get => 1e-6f;
    }
    public static float k_EpsilonNormalSqrt_float
    {
        [MethodImpl(256 | 512)]
        get => 1e-15f;
    }

    [MethodImpl(256 | 512)]
    public static quaternion svdRotation(float3x3 a)
    {
        // todo
        return new();
    }

    [MethodImpl(256 | 512)]
    private static float3 singularValuesDecomposition(float3x3 a, out quaternion u, out quaternion v)
    {
        u = quaternion.Identity;
        v = quaternion.Identity;

        var s = a.transpose().mul(a);
        v = jacobiIteration(ref s);
        var b = new float3x3(v);
        b = a.mul(b);
        sortSingularValues(ref b, ref v);
        u = givensQRFactorization(b, out var e);

        return new(e.c0.x, e.c1.y, e.c2.z);
    }

    [MethodImpl(256 | 512)]
    private static quaternion jacobiIteration(ref float3x3 s, int iterations = 5)
    {
        float3x3 qm;
        quaternion q;
        quaternion v = quaternion.Identity;

        for (var i = 0; i < iterations; ++i)
        {
            q = approxGivensQuat(new float3(s.c0.x, s.c1.y, s.c0.y), new float4(0f, 0f, 1f, 1f));
            v = v.mul(q);
            qm = new float3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new float3(s.c1.y, s.c2.z, s.c1.z), new float4(1f, 0f, 0f, 1f));
            v = v.mul(q);
            qm = new float3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new float3(s.c2.z, s.c0.x, s.c2.x), new float4(0f, 1f, 0f, 1f));
            v = v.mul(q);
            qm = new float3x3(q);
            s = qm.transpose().mul(s).mul(qm);
        } 

        return v;
    }

    [MethodImpl(256 | 512)]
    private static quaternion approxGivensQuat(float3 pq, float4 mask)
    {
        var c8 = 0.9238795325112867561281831893967882868224166258636424861150977312f; // cos(pi/8)
        var s8 = 0.3826834323650897717284599840303988667613445624856270414338006356f; // sin(pi/8)
        var g = 5.8284271247461900976033774484193961571393437507538961463533594759f; // 3 + 2 * sqrt(2)

        var ch = (2.0f * (pq.x - pq.y)); // approx cos(a/2)
        var sh = pq.z; // approx sin(a/2)
        var r = (g * sh * sh < ch * ch ? new float4(sh, sh, sh, ch) : new float4(s8, s8, s8, c8)) * mask;
        return r.normalize();
    }

    [MethodImpl(256 | 512)]
    private static void sortSingularValues(ref float3x3 b, ref quaternion v)
    {
        var l0 = b.c0.lengthsq();
        var l1 = b.c1.lengthsq();
        var l2 = b.c2.lengthsq();

        var c = l0 < l1;
        condNegSwap(c, ref b.c0, ref b.c1);
        v = condNegSwapQuat(c, v, new float4(0f, 0f, 1f, 1f));
        condSwap(c, ref l0, ref l1);

        c = l0 < l2;
        condNegSwap(c, ref b.c0, ref b.c2);
        v = condNegSwapQuat(c, v, new float4(0f, -1f, 0f, 1f));
        condSwap(c, ref l0, ref l2);

        c = l1 < l2;
        condNegSwap(c, ref b.c1, ref b.c2);
        v = condNegSwapQuat(c, v, new float4(1f, 0f, 0f, 1f));
    }

    [MethodImpl(256 | 512)]
    private static void condNegSwap(bool c, ref float3 x, ref float3 y)
    {
        var tmp = -x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static void condSwap(bool c, ref float x, ref float y)
    {
        var tmp = x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static quaternion condNegSwapQuat(bool c, quaternion q, float4 mask)
    {
        var halfSqrt2 = 0.7071067811865475244008443621048490392848359376884740365883398689f;
        return q.mul(c ? mask * halfSqrt2 : quaternion.Identity.value);
    }

    [MethodImpl(256 | 512)]
    private static quaternion givensQRFactorization(float3x3 b, out float3x3 r)
    {
        var u = qrGivensQuat(new float2(b.c0.x, b.c0.y), new float4(0f, 0f, 1f, 1f));
        var qmt = new float3x3(u.conjugate());
        r = qmt.mul(b);

        var q = qrGivensQuat(new float2(r.c0.x, r.c0.z), new float4(0f, -1f, 0f, 1f));
        u = u.mul(q);
        qmt = new float3x3(q.conjugate());
        r = qmt.mul(r);

        q = qrGivensQuat(new float2(r.c1.y, r.c1.z), new float4(1f, 0f, 0f, 1f));
        u = u.mul(q);
        qmt = new float3x3(q.conjugate());
        r = qmt.mul(r);

        return u;
    }

    [MethodImpl(256 | 512)]
    private static quaternion qrGivensQuat(float2 pq, float4 mask)
    {
        var l = (math.sqrt(pq.x * pq.x + pq.y * pq.y));
        var sh = l > k_EpsilonNormalSqrt_float ? pq.y : default;
        var ch = (pq.x.abs() + l.max(k_EpsilonNormalSqrt_float));
        condSwap(pq.x < 0f, ref sh, ref ch);

        return math.normalize(new float4(sh, sh, sh, ch) * mask);
    }
}

#endregion // svd

#endregion // quaternion

#region quaternion_d

public partial struct quaternion_d
{
    public double4 value;

    public static quaternion_d Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, 1.0);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion_d(double x, double y, double z, double w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion_d(double4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion_d(double4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a double3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The double3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_d(double3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ulong)(u.x.asu() & 0x8000000000000000);
        var t = (v.y + ((ulong)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ulong4((ulong)(u_sign >> 63)).asf();
        var t_mask = new long4((long)(t.asi() >> 63)).asf();

        var tr = (1.0 + u.x.abs());

        var sign_flips =
            new ulong4(default, 0x8000000000000000, 0x8000000000000000, 0x8000000000000000).asf()
            ^ (u_mask & new ulong4(default, 0x8000000000000000, default, 0x8000000000000000).asf())
            ^ (t_mask & new ulong4(0x8000000000000000, 0x8000000000000000, 0x8000000000000000, default).asf());

        value = new double4(tr, u.y, w.x, v.z) + (new double4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal double4x4 matrix</summary>
    /// <param name="m">The double4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_d(double4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ulong)(u.x.asu() & 0x8000000000000000);
        var t = (v.y + ((ulong)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ulong4((ulong)(u_sign >> 63)).asf();
        var t_mask = new long4((long)(t.asi() >> 63)).asf();

        var tr = (1.0 + u.x.abs());

        var sign_flips =
            new ulong4(default, 0x8000000000000000, 0x8000000000000000, 0x8000000000000000).asf()
            ^ (u_mask & new ulong4(default, 0x8000000000000000, default, 0x8000000000000000).asf())
            ^ (t_mask & new ulong4(0x8000000000000000, 0x8000000000000000, 0x8000000000000000, default).asf());

        value = new double4(tr, u.y, w.x, v.z) + (new double4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d AxisAngle(double3 axis, double angle)
    {
        math.sincos((0.5 * angle), out var sina, out var cosa);
        return new(new double4(axis * sina, cosa));
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerXYZ(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(-1.0, 1.0, -1.0, 1.0)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerXZY(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(1.0, 1.0, -1.0, -1.0)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerYXZ(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(-1.0, 1.0, 1.0, -1.0)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerYZX(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(-1.0, -1.0, 1.0, 1.0)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerZXY(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(1.0, -1.0, -1.0, 1.0)
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A double3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d EulerZYX(double3 xyz)
    {
        var (s, c) = (xyz * 0.5).sincos();
        return new(
            new double4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new double4(c.xyz, s.x) * new double4(1.0, -1.0, 1.0, -1.0)
        );
    }

    /// <summary>Returns a quaternion that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d RotateX(double angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5));
        return new(sina, default, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d RotateY(double angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5));
        return new(default, sina, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the z-axis by a given number of radians.</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d RotateZ(double angle)
    {
        var (sina, cosa) = math.sincos((angle * 0.5));
        return new(default, default, sina, cosa);
    }

    /// <summary>
    /// Returns a quaternion view rotation given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="quaternion_d.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d LookRotation(double3 forward, double3 up)
    {
        var t = up.cross(forward).normalize();
        return new(new double3x3(t, forward.cross(t), forward));
    }

    /// <summary>
    /// Returns a quaternion view rotation given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation or the identity quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d LookRotationSafe(double3 forward, double3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<double>() && mx < math.MaxRotateSafe<double>()
             && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        return accept
            ? new quaternion_d(new double3x3(t, forward.cross(t), forward))
            : new quaternion_d(default, default, default, 1.0);
    }
}

public static partial class math
{
    /// <summary>Returns the conjugate of a quaternion value</summary>
    /// <param name="q">The quaternion to conjugate</param>
    /// <returns>The conjugate of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d conjugate(this quaternion_d q) => 
        new(q.value * new double4(-1.0, -1.0, -1.0, 1.0));

    /// <summary>Returns the inverse of a quaternion value</summary>
    /// <param name="q">The quaternion to invert</param>
    /// <returns>The quaternion inverse of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_d inverse(this quaternion_d q) => 
        new(q.dot(q).rcp() * q.value *  new double4(-1.0, -1.0, -1.0, 1.0));

    [MethodImpl(256 | 512)]
    public static double dot(this quaternion_d a, quaternion_d b) => a.value.dot(b.value);

    [MethodImpl(256 | 512)]
    public static double length(this quaternion_d q) => q.lengthsq().sqrt();

    [MethodImpl(256 | 512)]
    public static double lengthsq(this quaternion_d q) => q.dot(q);

    [MethodImpl(256 | 512)]
    public static quaternion_d normalize(this quaternion_d q) => new(q.dot(q).rsqrt() * q.value);

    [MethodImpl(256 | 512)]
    public static quaternion_d normalizesafe(this quaternion_d q)
    {
        var len = q.lengthsq();
        if (len > MinNormal<double>()) return quaternion_d.Identity;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d normalizesafe(this quaternion_d q, quaternion_d defaultValue)
    {
        var len = q.lengthsq();
        if (len > MinNormal<double>()) return defaultValue;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d unitexp(this quaternion_d q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new double4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d exp(this quaternion_d q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new double4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len) * q.value.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d unitlog(this quaternion_d q)
    {
        var w = q.value.w.clamp(-1.0, 1.0);
        var s = (acos(w) * rsqrt(1.0 - w*w));
        return new(new double4(q.value.xyz * s, default));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d log(this quaternion_d q)
    {
        var v_len_sq = q.value.xyz.lengthsq();
        var q_len_sq = v_len_sq + q.value.w * q.value.w;

        var s = (acos(clamp(q.value.w * q_len_sq.rsqrt(), -1.0, 1.0)) * v_len_sq.rsqrt());
        return new(new double4(q.value.xyz * s, (0.5 * q_len_sq.log())));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d mul(this quaternion_d a, quaternion_d b) => new(
        a.value.wwww * b.value + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) 
        * new double4(1.0, 1.0, 1.0, -1.0) - a.value.zxyz * b.value.yzxz
    );

    [MethodImpl(256 | 512)]
    public static double3 mul(this quaternion_d q, double3 v)
    {
        var t = 2.0 * q.value.xyz.cross(v);
        return v + q.value.w * t + q.value.xyz.cross(t);
    }

    [MethodImpl(256 | 512)]
    public static double3 rotate(this quaternion_d q, double3 v) => mul(q, v);

    [MethodImpl(256 | 512)]
    public static quaternion_d nlerp(this double t, quaternion_d q1, quaternion_d q2) => 
        normalize(q1.value + t * (chgsign(q2.value, dot(q1, q2)) - q1.value));
    
    [MethodImpl(256 | 512)]
    public static quaternion_d slerp(this double t, quaternion_d q1, quaternion_d q2)
    {
        var dt = dot(q1, q2);
        if (dt < 0.0)
        {
            dt = -dt;
            q2.value = -q2.value;
        }

        if (dt < 0.9995)
        {
            var angle = dt.acos();
            var s = (rsqrt(1.0 - dt * dt));    // 1.0f / sin(angle)
            var w1 = (sin(angle * (1.0 - t)) * s);
            var w2 = (sin(angle * t) * s);
            return new quaternion_d(q1.value * w1 + q2.value * w2);
        }
        else
        {
            // if the angle is small, use linear interpolation
            return t.nlerp(q1, q2);
        }
    }
    
    [MethodImpl(256 | 512)]
    public static double angle(this quaternion_d q1, quaternion_d q2)
    {
        var diff = q1.conjugate().mul(q2).normalize().value.xyz.length().asin();
        return (diff + diff);
    }
    
    [MethodImpl(256 | 512)]
    public static quaternion_d rotation(this double3x3 m)
    {
        var det = m.determinant();
        if (math.abs(1 - det) < svd.k_EpsilonDeterminant_double)
            return new(m);

        if (det.abs() > svd.k_EpsilonDeterminant_double)
        {
            var tmp = m * new double3(m.c0.lengthsq(), m.c1.lengthsq(), m.c2.lengthsq()).rsqrt();
            if (math.abs(1 - math.determinant(tmp)) < svd.k_EpsilonDeterminant_double)
                return new(tmp);
        }

        return svd.svdRotation(m);
    }
    
    [MethodImpl(256 | 512)]
    public static double3x3 adj(this double3x3 m, out double det)
    {
        double3x3 adjT;
        adjT.c0 = m.c1.cross(m.c2);
        adjT.c1 = m.c2.cross(m.c0);
        adjT.c2 = m.c0.cross(m.c1);
        det = m.c0.dot(adjT.c0);

        return adjT.transpose();
    }
    
    [MethodImpl(256 | 512)]
    public static bool adj(this double3x3 m, out double3x3 i)
    {
        var epsilon = 1e-300;
        return m.adj(out i, epsilon);
    }

    [MethodImpl(256 | 512)]
    public static bool adj(this double3x3 m, out double3x3 i, double epsilon)
    {
        i = adj(m, out double det);
        var c = det.abs() > epsilon;
        var detInv = c ? det.rcp() : new double3(1.0) ;
        i = detInv * i;
        return c;
    }
}

#region svd

internal static partial class svd
{
    public static double k_EpsilonDeterminant_double
    {
        [MethodImpl(256 | 512)]
        get => 1e-50;
    }
    public static double k_EpsilonNormalSqrt_double
    {
        [MethodImpl(256 | 512)]
        get => 1e-150;
    }

    [MethodImpl(256 | 512)]
    public static quaternion_d svdRotation(double3x3 a)
    {
        // todo
        return new();
    }

    [MethodImpl(256 | 512)]
    private static double3 singularValuesDecomposition(double3x3 a, out quaternion_d u, out quaternion_d v)
    {
        u = quaternion_d.Identity;
        v = quaternion_d.Identity;

        var s = a.transpose().mul(a);
        v = jacobiIteration(ref s);
        var b = new double3x3(v);
        b = a.mul(b);
        sortSingularValues(ref b, ref v);
        u = givensQRFactorization(b, out var e);

        return new(e.c0.x, e.c1.y, e.c2.z);
    }

    [MethodImpl(256 | 512)]
    private static quaternion_d jacobiIteration(ref double3x3 s, int iterations = 5)
    {
        double3x3 qm;
        quaternion_d q;
        quaternion_d v = quaternion_d.Identity;

        for (var i = 0; i < iterations; ++i)
        {
            q = approxGivensQuat(new double3(s.c0.x, s.c1.y, s.c0.y), new double4(0, 0, 1, 1));
            v = v.mul(q);
            qm = new double3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new double3(s.c1.y, s.c2.z, s.c1.z), new double4(1, 0, 0, 1));
            v = v.mul(q);
            qm = new double3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new double3(s.c2.z, s.c0.x, s.c2.x), new double4(0, 1, 0, 1));
            v = v.mul(q);
            qm = new double3x3(q);
            s = qm.transpose().mul(s).mul(qm);
        } 

        return v;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_d approxGivensQuat(double3 pq, double4 mask)
    {
        var c8 = 0.9238795325112867561281831893967882868224166258636424861150977312; // cos(pi/8)
        var s8 = 0.3826834323650897717284599840303988667613445624856270414338006356; // sin(pi/8)
        var g = 5.8284271247461900976033774484193961571393437507538961463533594759; // 3 + 2 * sqrt(2)

        var ch = (2.0 * (pq.x - pq.y)); // approx cos(a/2)
        var sh = pq.z; // approx sin(a/2)
        var r = (g * sh * sh < ch * ch ? new double4(sh, sh, sh, ch) : new double4(s8, s8, s8, c8)) * mask;
        return r.normalize();
    }

    [MethodImpl(256 | 512)]
    private static void sortSingularValues(ref double3x3 b, ref quaternion_d v)
    {
        var l0 = b.c0.lengthsq();
        var l1 = b.c1.lengthsq();
        var l2 = b.c2.lengthsq();

        var c = l0 < l1;
        condNegSwap(c, ref b.c0, ref b.c1);
        v = condNegSwapQuat(c, v, new double4(0, 0, 1, 1));
        condSwap(c, ref l0, ref l1);

        c = l0 < l2;
        condNegSwap(c, ref b.c0, ref b.c2);
        v = condNegSwapQuat(c, v, new double4(0, -1, 0, 1));
        condSwap(c, ref l0, ref l2);

        c = l1 < l2;
        condNegSwap(c, ref b.c1, ref b.c2);
        v = condNegSwapQuat(c, v, new double4(1, 0, 0, 1));
    }

    [MethodImpl(256 | 512)]
    private static void condNegSwap(bool c, ref double3 x, ref double3 y)
    {
        var tmp = -x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static void condSwap(bool c, ref double x, ref double y)
    {
        var tmp = x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_d condNegSwapQuat(bool c, quaternion_d q, double4 mask)
    {
        var halfSqrt2 = 0.7071067811865475244008443621048490392848359376884740365883398689;
        return q.mul(c ? mask * halfSqrt2 : quaternion_d.Identity.value);
    }

    [MethodImpl(256 | 512)]
    private static quaternion_d givensQRFactorization(double3x3 b, out double3x3 r)
    {
        var u = qrGivensQuat(new double2(b.c0.x, b.c0.y), new double4(0, 0, 1, 1));
        var qmt = new double3x3(u.conjugate());
        r = qmt.mul(b);

        var q = qrGivensQuat(new double2(r.c0.x, r.c0.z), new double4(0, -1, 0, 1));
        u = u.mul(q);
        qmt = new double3x3(q.conjugate());
        r = qmt.mul(r);

        q = qrGivensQuat(new double2(r.c1.y, r.c1.z), new double4(1, 0, 0, 1));
        u = u.mul(q);
        qmt = new double3x3(q.conjugate());
        r = qmt.mul(r);

        return u;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_d qrGivensQuat(double2 pq, double4 mask)
    {
        var l = (math.sqrt(pq.x * pq.x + pq.y * pq.y));
        var sh = l > k_EpsilonNormalSqrt_double ? pq.y : default;
        var ch = (pq.x.abs() + l.max(k_EpsilonNormalSqrt_double));
        condSwap(pq.x < 0, ref sh, ref ch);

        return math.normalize(new double4(sh, sh, sh, ch) * mask);
    }
}

#endregion // svd

#endregion // quaternion_d

#region quaternion_h

public partial struct quaternion_h
{
    public half4 value;

    public static quaternion_h Identity
    {
        [MethodImpl(256 | 512)]
        get => new(default, default, default, (half)1.0);
    }
    
    [MethodImpl(256 | 512)]
    public quaternion_h(half x, half y, half z, half w) => 
        value = new(x, y, z, w); 

    [MethodImpl(256 | 512)]
    public quaternion_h(half4 value) => this.value = value; 

    [MethodImpl(256 | 512)]
    public static implicit operator quaternion_h(half4 value) => new(value); 

    /// <summary>Constructs a unit quaternion from a half3x3 rotation matrix. The matrix must be orthonormal</summary>
    /// <param name="m">The half3x3 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_h(half3x3 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ushort)(u.x.asu() & 0x8000);
        var t = (half)(v.y + ((ushort)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ushort4((ushort)(u_sign >> 15)).asf();
        var t_mask = new short4((short)(t.asi() >> 15)).asf();

        var tr = (half)((half)1.0 + u.x.abs());

        var sign_flips =
            new ushort4(default, 0x8000, 0x8000, 0x8000).asf()
            ^ (u_mask & new ushort4(default, 0x8000, default, 0x8000).asf())
            ^ (t_mask & new ushort4(0x8000, 0x8000, 0x8000, default).asf());

        value = new half4(tr, u.y, w.x, v.z) + (new half4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>Constructs a unit quaternion from an orthonormal half4x4 matrix</summary>
    /// <param name="m">The half4x4 orthonormal rotation matrix</param>
    [MethodImpl(256 | 512)]
    public quaternion_h(half4x4 m)
    {
        var u = m.c0;
        var v = m.c1;
        var w = m.c2;

        var u_sign = (ushort)(u.x.asu() & 0x8000);
        var t = (half)(v.y + ((ushort)(w.z.asu() ^ u_sign)).asf());
        var u_mask = new ushort4((ushort)(u_sign >> 15)).asf();
        var t_mask = new short4((short)(t.asi() >> 15)).asf();

        var tr = (half)((half)1.0 + u.x.abs());

        var sign_flips =
            new ushort4(default, 0x8000, 0x8000, 0x8000).asf()
            ^ (u_mask & new ushort4(default, 0x8000, default, 0x8000).asf())
            ^ (t_mask & new ushort4(0x8000, 0x8000, 0x8000, default).asf());

        value = new half4(tr, u.y, w.x, v.z) + (new half4(t, v.x, u.z, w.y) ^ sign_flips); // +---, +++-, ++-+, +-++

        value = (value & ~u_mask) | (value.zwxy & u_mask);
        value = (value.wzyx & ~t_mask) | (value & t_mask);
        value = value.normalize();
    }

    /// <summary>
    /// Returns a quaternion representing a rotation around a unit axis by an angle in radians.
    /// The rotation direction is clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="axis">The axis of rotation</param>
    /// <param name="angle">The angle of rotation in radians</param>
    /// <returns>The quaternion representing a rotation around an axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h AxisAngle(half3 axis, half angle)
    {
        math.sincos((half)((half)0.5f * angle), out var sina, out var cosa);
        return new(new half4(axis * sina, cosa));
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the y-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-y-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerXYZ(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(-1.0f.half(), 1.0f.half(), -1.0f.half(), 1.0f.half())
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the x-axis, then the z-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in x-z-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerXZY(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(1.0f.half(), 1.0f.half(), -1.0f.half(), -1.0f.half())
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the x-axis and finally the z-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-x-z order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerYXZ(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(-1.0f.half(), 1.0f.half(), 1.0f.half(), -1.0f.half())
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the y-axis, then the z-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in y-z-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerYZX(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(-1.0f.half(), -1.0f.half(), 1.0f.half(), 1.0f.half())
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the x-axis and finally the y-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-x-y order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerZXY(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(1.0f.half(), -1.0f.half(), -1.0f.half(), 1.0f.half())
        );
    }

    /// <summary>
    /// Returns a quaternion constructed by first performing a rotation around the z-axis, then the y-axis and finally the x-axis.
    /// All rotation angles are in radians and clockwise when looking along the rotation axis towards the origin.
    /// </summary>
    /// <param name="xyz">A half3 vector containing the rotation angles around the x-, y- and z-axis measures in radians</param>
    /// <returns>The quaternion representing the Euler angle rotation in z-y-x order</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h EulerZYX(half3 xyz)
    {
        var (s, c) = (xyz * 0.5f.half()).sincos();
        return new(
            new half4(s.xyz, c.x) * c.yxxy * c.zzyz + s.yxxy * s.zzyz * new half4(c.xyz, s.x) * new half4(1.0f.half(), -1.0f.half(), 1.0f.half(), -1.0f.half())
        );
    }

    /// <summary>Returns a quaternion that rotates around the x-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the x-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the x-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h RotateX(half angle)
    {
        var (sina, cosa) = math.sincos((half)(angle * 0.5f.half()));
        return new(sina, default, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the y-axis by a given number of radians</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the y-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the y-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h RotateY(half angle)
    {
        var (sina, cosa) = math.sincos((half)(angle * 0.5f.half()));
        return new(default, sina, default, cosa);
    }

    /// <summary>Returns a quaternion that rotates around the z-axis by a given number of radians.</summary>
    /// <param name="angle">The clockwise rotation angle when looking along the z-axis towards the origin in radians</param>
    /// <returns>The quaternion representing a rotation around the z-axis</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h RotateZ(half angle)
    {
        var (sina, cosa) = math.sincos((half)(angle * 0.5f.half()));
        return new(default, default, sina, cosa);
    }

    /// <summary>
    /// Returns a quaternion view rotation given a unit length forward vector and a unit length up vector.
    /// The two input vectors are assumed to be unit length and not collinear.
    /// If these assumptions are not met use <see cref="quaternion_h.LookRotationSafe" /> instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h LookRotation(half3 forward, half3 up)
    {
        var t = up.cross(forward).normalize();
        return new(new half3x3(t, forward.cross(t), forward));
    }

    /// <summary>
    /// Returns a quaternion view rotation given a forward vector and an up vector.
    /// The two input vectors are not assumed to be unit length.
    /// If the magnitude of either of the vectors is so extreme that the calculation cannot be carried out reliably or the vectors are collinear,
    /// the identity will be returned instead.
    /// </summary>
    /// <param name="forward">The view forward direction</param>
    /// <param name="up">The view up direction</param>
    /// <returns>The quaternion view rotation or the identity quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h LookRotationSafe(half3 forward, half3 up)
    {
        var forwardLengthSq = forward.dot(forward);
        var upLengthSq = up.dot(up);

        forward *= forwardLengthSq.rsqrt();
        up *= upLengthSq.rsqrt();

        var t = up.cross(forward);
        var tLengthSq = t.dot(t);
        t *= tLengthSq.rsqrt();

        var mn = forwardLengthSq.min(upLengthSq).min(tLengthSq);
        var mx = forwardLengthSq.max(upLengthSq).max(tLengthSq);

        var accept = mn > math.MinRotateSafe<half>() && mx < math.MaxRotateSafe<half>()
             && forwardLengthSq.isFinite() && upLengthSq.isFinite() && tLengthSq.isFinite();
        return accept
            ? new quaternion_h(new half3x3(t, forward.cross(t), forward))
            : new quaternion_h(default, default, default, (half)1.0);
    }
}

public static partial class math
{
    /// <summary>Returns the conjugate of a quaternion value</summary>
    /// <param name="q">The quaternion to conjugate</param>
    /// <returns>The conjugate of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h conjugate(this quaternion_h q) => 
        new(q.value * new half4(-1.0f.half(), -1.0f.half(), -1.0f.half(), 1.0f.half()));

    /// <summary>Returns the inverse of a quaternion value</summary>
    /// <param name="q">The quaternion to invert</param>
    /// <returns>The quaternion inverse of the input quaternion</returns>
    [MethodImpl(256 | 512)]
    public static quaternion_h inverse(this quaternion_h q) => 
        new(q.dot(q).rcp() * q.value *  new half4(-1.0f.half(), -1.0f.half(), -1.0f.half(), 1.0f.half()));

    [MethodImpl(256 | 512)]
    public static half dot(this quaternion_h a, quaternion_h b) => a.value.dot(b.value);

    [MethodImpl(256 | 512)]
    public static half length(this quaternion_h q) => q.lengthsq().sqrt();

    [MethodImpl(256 | 512)]
    public static half lengthsq(this quaternion_h q) => q.dot(q);

    [MethodImpl(256 | 512)]
    public static quaternion_h normalize(this quaternion_h q) => new(q.dot(q).rsqrt() * q.value);

    [MethodImpl(256 | 512)]
    public static quaternion_h normalizesafe(this quaternion_h q)
    {
        var len = q.lengthsq();
        if (len > MinNormal<half>()) return quaternion_h.Identity;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h normalizesafe(this quaternion_h q, quaternion_h defaultValue)
    {
        var len = q.lengthsq();
        if (len > MinNormal<half>()) return defaultValue;
        return new(len.rsqrt() * q.value);
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h unitexp(this quaternion_h q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new half4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h exp(this quaternion_h q)
    {
        var v_rcp_len = q.value.xyz.lengthsq().rsqrt();
        var v_len = v_rcp_len.rcp();
        v_len.sincos(out var sin_v_len, out var cos_v_len);
        return new(new half4(q.value.xyz * v_rcp_len * sin_v_len, cos_v_len) * q.value.w.exp());
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h unitlog(this quaternion_h q)
    {
        var w = q.value.w.clamp(-1.0f.half(), 1.0f.half());
        var s = (half)(acos(w) * rsqrt(1.0f.half() - w*w));
        return new(new half4(q.value.xyz * s, default));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h log(this quaternion_h q)
    {
        var v_len_sq = q.value.xyz.lengthsq();
        var q_len_sq = v_len_sq + q.value.w * q.value.w;

        var s = (half)(acos(clamp(q.value.w * q_len_sq.rsqrt(), -1.0f.half(), 1.0f.half())) * v_len_sq.rsqrt());
        return new(new half4(q.value.xyz * s, (half)(0.5f.half() * q_len_sq.log())));
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h mul(this quaternion_h a, quaternion_h b) => new(
        a.value.wwww * b.value + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) 
        * new half4(1.0f.half(), 1.0f.half(), 1.0f.half(), -1.0f.half()) - a.value.zxyz * b.value.yzxz
    );

    [MethodImpl(256 | 512)]
    public static half3 mul(this quaternion_h q, half3 v)
    {
        var t = (half)2.0f * q.value.xyz.cross(v);
        return v + q.value.w * t + q.value.xyz.cross(t);
    }

    [MethodImpl(256 | 512)]
    public static half3 rotate(this quaternion_h q, half3 v) => mul(q, v);

    [MethodImpl(256 | 512)]
    public static quaternion_h nlerp(this half t, quaternion_h q1, quaternion_h q2) => 
        normalize(q1.value + t * (chgsign(q2.value, dot(q1, q2)) - q1.value));
    
    [MethodImpl(256 | 512)]
    public static quaternion_h slerp(this half t, quaternion_h q1, quaternion_h q2)
    {
        var dt = dot(q1, q2);
        if (dt < 0.0f.half())
        {
            dt = -dt;
            q2.value = -q2.value;
        }

        if (dt < 0.9995f.half())
        {
            var angle = dt.acos();
            var s = (half)(rsqrt(1.0f.half() - dt * dt));    // 1.0f / sin(angle)
            var w1 = (half)(sin(angle * (1.0f.half() - t)) * s);
            var w2 = (half)(sin(angle * t) * s);
            return new quaternion_h(q1.value * w1 + q2.value * w2);
        }
        else
        {
            // if the angle is small, use linear interpolation
            return t.nlerp(q1, q2);
        }
    }
    
    [MethodImpl(256 | 512)]
    public static half angle(this quaternion_h q1, quaternion_h q2)
    {
        var diff = q1.conjugate().mul(q2).normalize().value.xyz.length().asin();
        return (half)(diff + diff);
    }
    
    [MethodImpl(256 | 512)]
    public static quaternion_h rotation(this half3x3 m)
    {
        var det = m.determinant();
        if (math.abs(1f.half() - det) < svd.k_EpsilonDeterminant_half)
            return new(m);

        if (det.abs() > svd.k_EpsilonDeterminant_half)
        {
            var tmp = m * new half3(m.c0.lengthsq(), m.c1.lengthsq(), m.c2.lengthsq()).rsqrt();
            if (math.abs(1f.half() - math.determinant(tmp)) < svd.k_EpsilonDeterminant_half)
                return new(tmp);
        }

        return svd.svdRotation(m);
    }
    
    [MethodImpl(256 | 512)]
    public static half3x3 adj(this half3x3 m, out half det)
    {
        half3x3 adjT;
        adjT.c0 = m.c1.cross(m.c2);
        adjT.c1 = m.c2.cross(m.c0);
        adjT.c2 = m.c0.cross(m.c1);
        det = m.c0.dot(adjT.c0);

        return adjT.transpose();
    }
    
    [MethodImpl(256 | 512)]
    public static bool adj(this half3x3 m, out half3x3 i)
    {
        var epsilon = 1e-5f.half();
        return m.adj(out i, epsilon);
    }

    [MethodImpl(256 | 512)]
    public static bool adj(this half3x3 m, out half3x3 i, half epsilon)
    {
        i = adj(m, out half det);
        var c = det.abs() > epsilon;
        var detInv = c ? det.rcp() : new half3((half)1.0) ;
        i = detInv * i;
        return c;
    }
}

#region svd

internal static partial class svd
{
    public static half k_EpsilonDeterminant_half
    {
        [MethodImpl(256 | 512)]
        get => 1e-2f.half();
    }
    public static half k_EpsilonNormalSqrt_half
    {
        [MethodImpl(256 | 512)]
        get => 1e-3f.half();
    }

    [MethodImpl(256 | 512)]
    public static quaternion_h svdRotation(half3x3 a)
    {
        // todo
        return new();
    }

    [MethodImpl(256 | 512)]
    private static half3 singularValuesDecomposition(half3x3 a, out quaternion_h u, out quaternion_h v)
    {
        u = quaternion_h.Identity;
        v = quaternion_h.Identity;

        var s = a.transpose().mul(a);
        v = jacobiIteration(ref s);
        var b = new half3x3(v);
        b = a.mul(b);
        sortSingularValues(ref b, ref v);
        u = givensQRFactorization(b, out var e);

        return new(e.c0.x, e.c1.y, e.c2.z);
    }

    [MethodImpl(256 | 512)]
    private static quaternion_h jacobiIteration(ref half3x3 s, int iterations = 5)
    {
        half3x3 qm;
        quaternion_h q;
        quaternion_h v = quaternion_h.Identity;

        for (var i = 0; i < iterations; ++i)
        {
            q = approxGivensQuat(new half3(s.c0.x, s.c1.y, s.c0.y), new half4(0f.half(), 0f.half(), 1f.half(), 1f.half()));
            v = v.mul(q);
            qm = new half3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new half3(s.c1.y, s.c2.z, s.c1.z), new half4(1f.half(), 0f.half(), 0f.half(), 1f.half()));
            v = v.mul(q);
            qm = new half3x3(q);
            s = qm.transpose().mul(s).mul(qm);

            q = approxGivensQuat(new half3(s.c2.z, s.c0.x, s.c2.x), new half4(0f.half(), 1f.half(), 0f.half(), 1f.half()));
            v = v.mul(q);
            qm = new half3x3(q);
            s = qm.transpose().mul(s).mul(qm);
        } 

        return v;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_h approxGivensQuat(half3 pq, half4 mask)
    {
        var c8 = 0.9238795325112867561281831893967882868224166258636424861150977312f.half(); // cos(pi/8)
        var s8 = 0.3826834323650897717284599840303988667613445624856270414338006356f.half(); // sin(pi/8)
        var g = 5.8284271247461900976033774484193961571393437507538961463533594759f.half(); // 3 + 2 * sqrt(2)

        var ch = (half)((half)2.0f * (pq.x - pq.y)); // approx cos(a/2)
        var sh = pq.z; // approx sin(a/2)
        var r = (g * sh * sh < ch * ch ? new half4(sh, sh, sh, ch) : new half4(s8, s8, s8, c8)) * mask;
        return r.normalize();
    }

    [MethodImpl(256 | 512)]
    private static void sortSingularValues(ref half3x3 b, ref quaternion_h v)
    {
        var l0 = b.c0.lengthsq();
        var l1 = b.c1.lengthsq();
        var l2 = b.c2.lengthsq();

        var c = l0 < l1;
        condNegSwap(c, ref b.c0, ref b.c1);
        v = condNegSwapQuat(c, v, new half4(0f.half(), 0f.half(), 1f.half(), 1f.half()));
        condSwap(c, ref l0, ref l1);

        c = l0 < l2;
        condNegSwap(c, ref b.c0, ref b.c2);
        v = condNegSwapQuat(c, v, new half4(0f.half(), -1f.half(), 0f.half(), 1f.half()));
        condSwap(c, ref l0, ref l2);

        c = l1 < l2;
        condNegSwap(c, ref b.c1, ref b.c2);
        v = condNegSwapQuat(c, v, new half4(1f.half(), 0f.half(), 0f.half(), 1f.half()));
    }

    [MethodImpl(256 | 512)]
    private static void condNegSwap(bool c, ref half3 x, ref half3 y)
    {
        var tmp = -x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static void condSwap(bool c, ref half x, ref half y)
    {
        var tmp = x;
        x = c ? y : x;
        y = c ? tmp : y;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_h condNegSwapQuat(bool c, quaternion_h q, half4 mask)
    {
        var halfSqrt2 = 0.7071067811865475244008443621048490392848359376884740365883398689f.half();
        return q.mul(c ? mask * halfSqrt2 : quaternion_h.Identity.value);
    }

    [MethodImpl(256 | 512)]
    private static quaternion_h givensQRFactorization(half3x3 b, out half3x3 r)
    {
        var u = qrGivensQuat(new half2(b.c0.x, b.c0.y), new half4(0f.half(), 0f.half(), 1f.half(), 1f.half()));
        var qmt = new half3x3(u.conjugate());
        r = qmt.mul(b);

        var q = qrGivensQuat(new half2(r.c0.x, r.c0.z), new half4(0f.half(), -1f.half(), 0f.half(), 1f.half()));
        u = u.mul(q);
        qmt = new half3x3(q.conjugate());
        r = qmt.mul(r);

        q = qrGivensQuat(new half2(r.c1.y, r.c1.z), new half4(1f.half(), 0f.half(), 0f.half(), 1f.half()));
        u = u.mul(q);
        qmt = new half3x3(q.conjugate());
        r = qmt.mul(r);

        return u;
    }

    [MethodImpl(256 | 512)]
    private static quaternion_h qrGivensQuat(half2 pq, half4 mask)
    {
        var l = (half)(math.sqrt(pq.x * pq.x + pq.y * pq.y));
        var sh = l > k_EpsilonNormalSqrt_half ? pq.y : default;
        var ch = (half)(pq.x.abs() + l.max(k_EpsilonNormalSqrt_half));
        condSwap(pq.x < 0f.half(), ref sh, ref ch);

        return math.normalize(new half4(sh, sh, sh, ch) * mask);
    }
}

#endregion // svd

#endregion // quaternion_h
