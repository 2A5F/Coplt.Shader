// generated by template, do not modify manually

namespace Coplt.Mathematics;

#region float3

public partial struct float3 
{
    [MethodImpl(256 | 512)]
    public float3(float2 xy, float z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public float3(float x, float2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(Vector64.Create(x, default), yz.vector),
            Vector128.Create(0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal float3(float2 xz, float y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(xz.vector, Vector64.Create(y, default)),
            Vector128.Create(0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Ix(this float2 yz, float x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Iy(this float2 xz, float y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static float3 Iz(this float2 xy, float z) => new(xy, z);
}

#endregion // float3

#region double3

public partial struct double3 
{
    [MethodImpl(256 | 512)]
    public double3(double2 xy, double z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public double3(double x, double2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(Vector128.Create(x, default), yz.vector),
            Vector256.Create(0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal double3(double2 xz, double y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(xz.vector, Vector128.Create(y, default)),
            Vector256.Create(0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Ix(this double2 yz, double x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Iy(this double2 xz, double y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static double3 Iz(this double2 xy, double z) => new(xy, z);
}

#endregion // double3

#region int3

public partial struct int3 
{
    [MethodImpl(256 | 512)]
    public int3(int2 xy, int z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public int3(int x, int2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(Vector64.Create(x, default), yz.vector),
            Vector128.Create(0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal int3(int2 xz, int y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(xz.vector, Vector64.Create(y, default)),
            Vector128.Create(0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Ix(this int2 yz, int x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Iy(this int2 xz, int y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static int3 Iz(this int2 xy, int z) => new(xy, z);
}

#endregion // int3

#region uint3

public partial struct uint3 
{
    [MethodImpl(256 | 512)]
    public uint3(uint2 xy, uint z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public uint3(uint x, uint2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(Vector64.Create(x, default), yz.vector),
            Vector128.Create((uint)0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal uint3(uint2 xz, uint y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(xz.vector, Vector64.Create(y, default)),
            Vector128.Create((uint)0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Ix(this uint2 yz, uint x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Iy(this uint2 xz, uint y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static uint3 Iz(this uint2 xy, uint z) => new(xy, z);
}

#endregion // uint3

#region long3

public partial struct long3 
{
    [MethodImpl(256 | 512)]
    public long3(long2 xy, long z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public long3(long x, long2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(Vector128.Create(x, default), yz.vector),
            Vector256.Create(0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal long3(long2 xz, long y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(xz.vector, Vector128.Create(y, default)),
            Vector256.Create(0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Ix(this long2 yz, long x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Iy(this long2 xz, long y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static long3 Iz(this long2 xy, long z) => new(xy, z);
}

#endregion // long3

#region ulong3

public partial struct ulong3 
{
    [MethodImpl(256 | 512)]
    public ulong3(ulong2 xy, ulong z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public ulong3(ulong x, ulong2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(Vector128.Create(x, default), yz.vector),
            Vector256.Create((ulong)0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal ulong3(ulong2 xz, ulong y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(xz.vector, Vector128.Create(y, default)),
            Vector256.Create((ulong)0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Ix(this ulong2 yz, ulong x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Iy(this ulong2 xz, ulong y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static ulong3 Iz(this ulong2 xy, ulong z) => new(xy, z);
}

#endregion // ulong3

#region decimal3

public partial struct decimal3 
{
    [MethodImpl(256 | 512)]
    public decimal3(decimal2 xy, decimal z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public decimal3(decimal x, decimal2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal decimal3(decimal2 xz, decimal y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Ix(this decimal2 yz, decimal x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Iy(this decimal2 xz, decimal y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static decimal3 Iz(this decimal2 xy, decimal z) => new(xy, z);
}

#endregion // decimal3

#region half3

public partial struct half3 
{
    [MethodImpl(256 | 512)]
    public half3(half2 xy, half z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public half3(half x, half2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal half3(half2 xz, half y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Ix(this half2 yz, half x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Iy(this half2 xz, half y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static half3 Iz(this half2 xy, half z) => new(xy, z);
}

#endregion // half3

#region b16v3

public partial struct b16v3 
{
    [MethodImpl(256 | 512)]
    public b16v3(b16v2 xy, b16 z)
    {
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
    }

    [MethodImpl(256 | 512)]
    public b16v3(b16 x, b16v2 yz)
    {
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
    }

    [MethodImpl(256 | 512)]
    internal b16v3(b16v2 xz, b16 y, insert_y _)
    {
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Ix(this b16v2 yz, b16 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Iy(this b16v2 xz, b16 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b16v3 Iz(this b16v2 xy, b16 z) => new(xy, z);
}

#endregion // b16v3

#region b32v3

public partial struct b32v3 
{
    [MethodImpl(256 | 512)]
    public b32v3(b32v2 xy, b32 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Create(xy.vector, Vector64.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b32v3(b32 x, b32v2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(Vector64.Create(x, default), yz.vector),
            Vector128.Create((uint)0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal b32v3(b32v2 xz, b32 y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector128.Shuffle(
            Vector128.Create(xz.vector, Vector64.Create(y, default)),
            Vector128.Create((uint)0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Ix(this b32v2 yz, b32 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Iy(this b32v2 xz, b32 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b32v3 Iz(this b32v2 xy, b32 z) => new(xy, z);
}

#endregion // b32v3

#region b64v3

public partial struct b64v3 
{
    [MethodImpl(256 | 512)]
    public b64v3(b64v2 xy, b64 z)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Create(xy.vector, Vector128.Create(z, default));
        #else // NET8_0_OR_GREATER
        this.x = xy.x;
        this.y = xy.y;
        this.z = z;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    public b64v3(b64 x, b64v2 yz)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(Vector128.Create(x, default), yz.vector),
            Vector256.Create((ulong)0, 2, 3, 1)
        );
        #else // NET8_0_OR_GREATER
        this.x = x;
        this.y = yz.x;
        this.z = yz.y;
        #endif // NET8_0_OR_GREATER
    }

    [MethodImpl(256 | 512)]
    internal b64v3(b64v2 xz, b64 y, insert_y _)
    {
        #if NET8_0_OR_GREATER
        vector = Vector256.Shuffle(
            Vector256.Create(xz.vector, Vector128.Create(y, default)),
            Vector256.Create((ulong)0, 2, 1, 3)
        );
        #else // NET8_0_OR_GREATER
        this.x = xz.x;
        this.y = y;
        this.z = xz.y;
        #endif // NET8_0_OR_GREATER
    }
}

public static partial class math
{
    /// <summary>
    /// Insert X component
    /// <code>X -> (y, z) => (X, y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Ix(this b64v2 yz, b64 x) => new(x, yz);

    /// <summary>
    /// Insert Y component
    /// <code>Y -> (x, z) => (x, Y, z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Iy(this b64v2 xz, b64 y) => new(xz, y, new insert_y());

    /// <summary>
    /// Insert Z component
    /// <code>Z -> (x, y) => (x, y, Z)</code>
    /// </summary>
    [MethodImpl(256 | 512)]
    public static b64v3 Iz(this b64v2 xy, b64 z) => new(xy, z);
}

#endregion // b64v3
