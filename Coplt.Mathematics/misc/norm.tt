<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="../types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics.Numerics;
<#
    for (int si = 0; si < 2; si++)
    {
        var sig = si == 0;
        var min = sig ? -1 : 0;

        for (var s = 1; s <= 8; s *= 2)
        {
            var bitSize = 8 * s;
            var typeName = $"{(sig ? "i" : "u")}norm{bitSize}";
            var innerTypeName = $"{(sig ? "i" : "u")}{bitSize}";
#>

#region <#= typeName #>

/// <summary>
/// <#= bitSize #> bits normalized <#= sig ? "signed" : "unsigned" #> number (<#= sig ? "-1 .. 1" : "0 .. 1" #>)
/// </summary>
[Serializable]
public readonly partial struct <#= typeName #> : IEquatable<<#= typeName #>>, IComparable<<#= typeName #>>, IComparable
    #if NET8_0_OR_GREATER
    , IEqualityOperators<<#= typeName #>, <#= typeName #>, bool>
    , IComparisonOperators<<#= typeName #>, <#= typeName #>, bool>
    #endif
{
    private readonly <#= innerTypeName #> inner;

    [MethodImpl(256 | 512)]
    private <#= typeName #>(<#= innerTypeName #> inner) => this.inner = inner;

    #region Convert

    [MethodImpl(256 | 512)]
    public static implicit operator f16(<#= typeName #> a) => math.remap((f16)a.inner, (f16)<#= innerTypeName #>.MinValue, (f16)<#= innerTypeName #>.MaxValue, (f16)(<#= min #>), (f16)1);

    [MethodImpl(256 | 512)]
    public static implicit operator f32(<#= typeName #> a) => math.remap((f32)a.inner, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue, <#= min #>, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator f64(<#= typeName #> a) => math.remap((f64)a.inner, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue, <#= min #>, 1);

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(f16 a) => new((<#= innerTypeName #>)math.remap(a, (f16)(<#= min #>), (f16)1, (f16)<#= innerTypeName #>.MinValue, (f16)<#= innerTypeName #>.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(f32 a) => new((<#= innerTypeName #>)math.remap(a, <#= min #>, 1, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue));

    [MethodImpl(256 | 512)]
    public static implicit operator <#= typeName #>(f64 a) => new((<#= innerTypeName #>)math.remap(a, <#= min #>, 1, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue));

    [MethodImpl(256 | 512)]
    public f16 ToHalf(f16 min, f16 max) => (f16)math.remap((f32)inner, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue, (f32)min, (f32)max);

    [MethodImpl(256 | 512)]
    public f32 ToSingle(f32 min, f32 max) => math.remap((f32)inner, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public f64 ToDouble(f64 min, f64 max) => math.remap((f64)inner, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue, min, max);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> FromHalf(f16 a, f16 min, f16 max) => new((<#= innerTypeName #>)math.remap(a, (f16)min, (f16)max, (f16)<#= innerTypeName #>.MinValue, (f16)<#= innerTypeName #>.MaxValue));

    [MethodImpl(256 | 512)]
    public static <#= typeName #> FromSingle(f32 a, f32 min, f32 max) => new((<#= innerTypeName #>)math.remap(a, min, max, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue));

    [MethodImpl(256 | 512)]
    public static <#= typeName #> FromDouble(f64 a, f64 min, f64 max) => new((<#= innerTypeName #>)math.remap(a, min, max, <#= innerTypeName #>.MinValue, <#= innerTypeName #>.MaxValue));

    #endregion // Convert

    #region ToString

    [CpuOnly]
    public override string ToString() => $"{(f64)this}";

    #endregion // ToString

    #region Equals

    [MethodImpl(256 | 512)]
    public bool Equals(<#= typeName #> other) => inner == other.inner;

    [MethodImpl(256 | 512)]
    public override bool Equals(object? obj) => obj is <#= typeName #> other && Equals(other);

    [MethodImpl(256 | 512)]
    public override int GetHashCode() => inner.GetHashCode();

    [MethodImpl(256 | 512)]
    public static bool operator ==(<#= typeName #> left, <#= typeName #> right) => left.inner == right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator !=(<#= typeName #> left, <#= typeName #> right) => left.inner != right.inner;

    #endregion

    #region CompareTo

    [MethodImpl(256 | 512)]
    public int CompareTo(<#= typeName #> other) => inner.CompareTo(other.inner);

    [MethodImpl(256 | 512)]
    public int CompareTo(object? obj)
    {
        if (ReferenceEquals(null, obj)) return 1;
        return obj is <#= typeName #> other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(<#= typeName #>)}");
    }

    [MethodImpl(256 | 512)]
    public static bool operator <(<#= typeName #> left, <#= typeName #> right) => left.inner < right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >(<#= typeName #> left, <#= typeName #> right) => left.inner > right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator <=(<#= typeName #> left, <#= typeName #> right) => left.inner <= right.inner;

    [MethodImpl(256 | 512)]
    public static bool operator >=(<#= typeName #> left, <#= typeName #> right) => left.inner >= right.inner;

    #endregion
}

#endregion // <#= typeName #>
<#
        }
    }
#>
