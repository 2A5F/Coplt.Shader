<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="types.ttinclude" #><#@ import namespace="System.Linq" #>// generated by template, do not modify manually

namespace Coplt.Mathematics;
<#
    foreach (var typ in Typ.Typs)
    {
        if (!typ.f) continue;
        if (!typ.arith) continue;

        for (var i = 2; i <= 4; i++)
        {
            var typeName = $"{typ.name}{i}";

            var byteSize = typ.size * (i is 3 ? 4 : i);
            var bitSize = 8 * byteSize;
#>

#region <#= typeName #>

public partial struct <#= typeName #>
{
    /// <summary>
    /// <code>e</code>
    /// </summary>
    public static <#= typeName #> E
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.7182818284590452353602874713526624977572470936999595749669676277<#= typ.suffix #>); 
    }
    /// <summary>
    /// <code>log(2)</code>
    /// </summary>
    public static <#= typeName #> Log2
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.6931471805599453094172321214581765680755001343602552541206800094<#= typ.suffix #>); 
    }
    /// <summary>
    /// <code>log(10)</code>
    /// </summary>
    public static <#= typeName #> Log10
    { 
        [MethodImpl(256 | 512)] 
        get => new(2.3025850929940456840179914546843642076011014886287729760333279009<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>π</code>
    /// </summary>
    public static <#= typeName #> PI
    { 
        [MethodImpl(256 | 512)] 
        get => new(3.1415926535897932384626433832795028841971693993751058209749445923<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>τ = 2 * π</code>
    /// </summary>
    public static <#= typeName #> Tau
    { 
        [MethodImpl(256 | 512)] 
        get => new(6.2831853071795864769252867665590057683943387987502116419498891846<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>360 / τ</code>
    /// </summary>
    public static <#= typeName #> RadToDeg
    { 
        [MethodImpl(256 | 512)] 
        get => new(57.295779513082320876798154814105170332405472466564321549160243861<#= typ.suffix #>);
    }
    /// <summary>
    /// <code>τ / 360</code>
    /// </summary>
    public static <#= typeName #> DegToRad
    { 
        [MethodImpl(256 | 512)] 
        get => new(0.0174532925199432957692369076848861271344287188854172545609719144<#= typ.suffix #>);
    }
}

public static partial class math
{

    [MethodImpl(256 | 512)]
    public static <#= typeName #> ceil(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Ceiling(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.ceil()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> floor(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(Vector<#= bitSize #>.Floor(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.floor()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> round(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Round(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.round()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> trunc(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(simd.Truncate(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.trunc()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> frac(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return new(a.vector - Vector<#= bitSize #>.Floor(a.vector));
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.frac()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> modf(this <#= typeName #> a, out <#= typeName #> i)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        var r = simd.ModF(a.vector, out var iv);
        i = new(iv);
        return new(r);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        <#= typeName #> r = new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.modf(out var i{n})")) #>);
        i = new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"i{n}")) #>);
        return r;
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> rcp(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return <#= typeName #>.One / a;
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.rcp()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> saturate(this <#= typeName #> a)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        return a.clamp(default, <#= typeName #>.One);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return new(<#= string.Join(", ", Enumerable.Range(0, i).Select(n => $"a.{Typ.xyzw[n]}.saturate()")) #>);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(this <#= typeName #> t, <#= typeName #> start, <#= typeName #> end)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(t, end - start, start);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return start + t * (end - start);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> lerp(this <#= typ.simdComp #> t, <#= typeName #> start, <#= typeName #> end)
    {
<#
            if (typ.simd)
            {
#>
        #if NET8_0_OR_GREATER
        // start + t * (end - start)
        return fma(new(t), end - start, start);
        #else // NET8_0_OR_GREATER
<#
            }
#>
        return start + t * (end - start);
<#
            if (typ.simd)
            {
#>
        #endif // NET8_0_OR_GREATER
<#
            }
#>
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp(this <#= typeName #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> unlerp(this <#= typ.simdComp #> a, <#= typeName #> start, <#= typeName #> end) => (a - start) / (end - start);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> remap(this <#= typeName #> a, <#= typeName #> srcStart, <#= typeName #> srcEnd, <#= typeName #> dstStart, <#= typeName #> dstEnd) => 
        a.unlerp(srcStart, srcEnd).lerp(dstStart, dstEnd);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> smoothstep(this <#= typeName #> a, <#= typeName #> min, <#= typeName #> max)
    {
        var t = saturate((a - min) / (max - min));
        return t * t * (3.0<#= typ.suffix #> - (2.0<#= typ.suffix #> * t));
    }

    [MethodImpl(256 | 512)]
    public static <#= typeName #> reflect(this <#= typeName #> i, <#= typeName #> n) => i - 2<#= typ.suffix #> * n * dot(i, n);

    [MethodImpl(256 | 512)]
    public static <#= typeName #> project(this <#= typeName #> a, <#= typeName #> onto) =>
        (<#= typ.simdComp #>)(dot(a, onto) / dot(onto, onto)) * onto;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> radians(this <#= typeName #> a) => a * <#= typeName #>.DegToRad;

    [MethodImpl(256 | 512)]
    public static <#= typeName #> degrees(this <#= typeName #> a) => a * <#= typeName #>.RadToDeg;
}

#endregion // <#= typeName #>
<#
        }
    }
#>
